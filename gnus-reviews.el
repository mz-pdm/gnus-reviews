;;; gnus-reviews.el --- Email-based code review management for Gnus  -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Red Hat, Inc.

;; Author: Claude Code <noreply@anthropic.com>
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1") (gnus "5.13"))
;; Keywords: mail, gnus, code-review, development
;; URL: https://github.com/mz-pdm/gnus-reviews
;; Homepage: https://github.com/mz-pdm/gnus-reviews

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package provides tools for managing email-based code reviews in Gnus.
;; It helps organize review messages into appropriate groups, track individual
;; comments and their status, and manage the review lifecycle.
;;
;; Main features:
;; - Automatic classification of patch emails vs. review comments
;; - Organization of messages into purpose-specific Gnus groups
;; - Comment tracking and status management
;; - Review pruning and cleanup
;; - Score boosting for review-relevant articles
;;
;; While designed with libcamera development in mind, this package is generic
;; and can be used with any email-based code review workflow.

;;; Code:

(require 'gnus)
(require 'gnus-sum)
(require 'gnus-art)
(require 'gnus-score)
(require 'gnus-group)
(require 'message)
(require 'cl-lib)

;;; Constants and Variables

(defgroup gnus-reviews nil
  "Email-based code review management for Gnus."
  :group 'gnus
  :prefix "gnus-reviews-")

(defcustom gnus-reviews-base-group "nnml:reviews"
  "Base group name for review-related messages."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-own-patches-group (concat gnus-reviews-base-group ".patches")
  "Group for reviews of your own patches."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-to-review-group (concat gnus-reviews-base-group ".reviews")
  "Group for patches you intend to review."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-watching-group (concat gnus-reviews-base-group ".watching")
  "Group for patches you want to watch without reviewing."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-finished-group (concat gnus-reviews-base-group ".finished")
  "Group for completed reviews."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-score-increase 1000
  "Score increase for review-relevant articles."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-expire-days 30
  "Number of days after which completed reviews are auto-expired."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-data-file "~/.emacs.d/gnus-reviews-data.el"
  "File to store persistent review data."
  :type 'file
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-email nil
  "Email address to use for identifying own patches.
If nil, uses `user-mail-address'."
  :type '(choice (const :tag "Use user-mail-address" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-name nil
  "Full name to use for identifying own patches.
If nil, uses `user-full-name'."
  :type '(choice (const :tag "Use user-full-name" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-create-groups t
  "Whether to automatically create review groups if they don't exist."
  :type 'boolean
  :group 'gnus-reviews)

(defvar gnus-reviews-comment-database nil
  "Database of tracked review comments.
Format: ((message-id . ((comment-id . comment-plist) ...)) ...)
where comment-plist is
(:status status :content content :thread-id thread-id :timestamp timestamp :context context)")

;;; Data Persistence Functions

(defun gnus-reviews--save-data ()
  "Save review data to persistent storage."
  (with-temp-file gnus-reviews-data-file
    (insert ";; Gnus Reviews Data File\n")
    (insert ";; This file is automatically generated. Do not edit manually.\n\n")
    (insert "(setq gnus-reviews-comment-database (quote\n")
    (prin1 gnus-reviews-comment-database (current-buffer))
    (insert "))\n")))

(defun gnus-reviews--load-data ()
  "Load review data from persistent storage."
  (when (and gnus-reviews-data-file (file-exists-p gnus-reviews-data-file))
    (load gnus-reviews-data-file t t)))

(defun gnus-reviews--comments ()
  (unless gnus-reviews-comment-database
    (gnus-reviews--load-data))
  gnus-reviews-comment-database)

(defun gnus-reviews--store-comments (comments)
  (setq gnus-reviews-comment-database comments)
  (gnus-reviews--save-data))

;;; Group Management Functions

(defun gnus-reviews--group-exists-p (group)
  "Check if GROUP exists in Gnus."
  (and group (gnus-group-entry group)))

(defun gnus-reviews--create-group (group)
  "Create GROUP if it doesn't exist and auto-creation is enabled."
  (when (and gnus-reviews-auto-create-groups
             group
             (not (gnus-reviews--group-exists-p group)))
    (gnus-group-make-group (gnus-group-short-name group) "nnml" "")
    (message "Created review group: %s" group)))

(defun gnus-reviews--ensure-groups ()
  "Ensure all review groups exist, creating them if necessary."
  (unless (and (boundp 'gnus-group-buffer)
               gnus-group-buffer
               (get-buffer gnus-group-buffer))
    (error "Gnus group buffer is not available - ensure Gnus is running"))
  (with-current-buffer gnus-group-buffer
    (mapc #'gnus-reviews--create-group
          (list gnus-reviews-base-group
                gnus-reviews-own-patches-group
                gnus-reviews-to-review-group
                gnus-reviews-watching-group
                gnus-reviews-finished-group))))

;;; Validation and Initialization Functions

(defun gnus-reviews--get-user-email ()
  "Get the user's email address for patch identification."
  (or gnus-reviews-user-email user-mail-address))

(defun gnus-reviews--get-user-name ()
  "Get the user's full name for patch identification."
  (or gnus-reviews-user-name user-full-name))

;;; Utility Functions

(defun gnus-reviews--article-header (func field)
  (cond
   ;; Try to get from article buffer context first (most reliable)
   ((and (boundp 'gnus-current-headers) gnus-current-headers)
    (funcall func gnus-current-headers))
   ;; Try getting from article buffer if we're in one
   ((gnus-buffer-live-p gnus-article-buffer)
    (with-current-buffer gnus-article-buffer
      (when (and (boundp 'gnus-current-headers) gnus-current-headers)
        (funcall func gnus-current-headers))))
   ;; Fall back to summary buffer approach
   ((and (gnus-summary-article-number)
         (gnus-summary-article-header))
    (funcall func (gnus-summary-article-header)))
   ;; Last resort: try to extract from raw article headers
   (t
    (gnus-with-article-headers
      (gnus-fetch-field field)))))

(defun gnus-reviews--current-article-id ()
  "Return the Message-ID of the current article."
  (gnus-reviews--article-header #'mail-header-id "Message-ID"))

(defun gnus-reviews--current-thread-id ()
  "Get the thread ID of the current article.
Uses References headers to determine thread membership,
falls back to Message-ID if no References header is available."
  (or (when-let ((refs (gnus-reviews--article-header #'mail-header-references "References")))
        (unless (equal refs "")
          (car (split-string refs " "))))
      (gnus-reviews--current-article-id)))

;;; Message Classification

(defcustom gnus-reviews-patch-patterns
  '("^\\[PATCH[^]]*\\]" "^\\[RFC[^]]*\\]" "^diff --git" "^---.*\\+\\+\\+" "^Index: ")
  "Patterns that indicate a message contains a patch."
  :type '(repeat string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-review-patterns
  '("^Re:.*\\[PATCH" "^Re:.*\\[RFC" "Reviewed-by:" "Acked-by:" "Tested-by:"
    "^On .* wrote:" "> .*" "inline comment")
  "Patterns that indicate a message is a review comment."
  :type '(repeat string)
  :group 'gnus-reviews)

(defun gnus-reviews--match-patterns (content patterns)
  "Check if CONTENT matches any of the PATTERNS."
  (cl-some (lambda (pattern)
             (string-match-p pattern content))
           patterns))

(defun gnus-reviews-is-patch-email-p ()
  "Return non-nil if current article is a patch email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string)))
      (or (and subject (gnus-reviews--match-patterns subject gnus-reviews-patch-patterns))
          (gnus-reviews--match-patterns content gnus-reviews-patch-patterns)))))

(defun gnus-reviews-is-own-patch-email-p ()
  "Return non-nil if current article is a patch by the user."
  (gnus-with-article-buffer
    (let ((from (gnus-fetch-field "From"))
          (user-email (gnus-reviews--get-user-email))
          (user-name (gnus-reviews--get-user-name)))
      (and from
           (or (and user-email (string-match (regexp-quote user-email) from))
               (and user-name (string-match (regexp-quote user-name) from)))
           (gnus-reviews-is-patch-email-p)))))

(defun gnus-reviews-is-review-email-p ()
  "Return non-nil if current article is a review email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string))
          (in-reply-to (gnus-fetch-field "In-Reply-To")))
      (and subject
           (not (gnus-reviews-is-patch-email-p))
           (or in-reply-to (string-match "^Re:" subject))
           (or (gnus-reviews--match-patterns subject gnus-reviews-review-patterns)
               (gnus-reviews--match-patterns content gnus-reviews-review-patterns))))))

(defun gnus-reviews-extract-patch-info ()
  "Extract patch information from the current article.
Returns a plist with :series-num, :series-total, :version, :subject."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject")))
      (when subject
        (cond
         ;; PATCH series with version and series numbers
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))))
         ;; RFC series with version and series numbers
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))
                :rfc t))
         ;; Single PATCH with version
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))))
         ;; Single RFC with version
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))
                :rfc t)))))))

;;; Comment Tracking System

(defun gnus-reviews--generate-comment-id (article-id comment-order)
  "Generate a deterministic unique comment ID.
ARTICLE-ID identifies the article, COMMENT-ORDER is the sequential order
of this comment within the article (1-based)."
  (format "%s#%d" article-id comment-order))

(defun gnus-reviews--parse-individual-comments ()
  "Parse individual review comments from current article.
Returns a list of (content start-pos end-pos context) for each comment."
  (gnus-with-article-buffer
    (let ((content (buffer-string))
          (comments '())
          (body-start 0))
      ;; Skip headers
      (when (string-match "\n\n" content)
        (setq body-start (match-end 0)))

      (with-temp-buffer
        (insert (substring content body-start))
        (goto-char (point-min))

        (let ((current-context nil)
              (comment-lines '())
              (comment-start-pos nil))

          (while (not (eobp))
            (cond
             ;; Found quoted line - save any accumulated comment block first
             ((looking-at "^> \\(.+\\)$")
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))
              ;; Update context for future comments
              (setq current-context (match-string-no-properties 1)))

             ;; Found non-quoted, non-empty line
             ((looking-at "^\\([^>\n].*\\)$")
              (let ((line-text (save-match-data (string-trim (match-string-no-properties 1)))))
                ;; Exclude signature lines, headers, but include actual comment content
                (when (and (> (length line-text) 0)
                           (string-match "\\w" line-text)
                           (not (string-match "^\\(On \\|--\\|___\\|From:\\|Subject:\\)" line-text)))
                  (when (null comment-start-pos)
                    (setq comment-start-pos (line-beginning-position)))
                  (push line-text comment-lines))))

             ;; Empty line or other - save accumulated comment block if any
             (t
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))))

            (forward-line 1))

          ;; Handle any remaining comment block at end of buffer
          (when comment-lines
            (let ((comment-text (string-join (nreverse comment-lines) "\n")))
              (when (and (> (length comment-text) 0)
                         (string-match "\\w" comment-text))
                (push (list comment-text
                            (+ body-start comment-start-pos)
                            (+ body-start (point-max))
                            current-context)
                      comments))))))

      (nreverse comments))))

(defun gnus-reviews-track-individual-comment (comment-text status comment-order &optional context)
  "Track an individual review comment.
COMMENT-TEXT is the actual comment content.
STATUS should be one of: `pending', `addressed', `dismissed'.
COMMENT-ORDER is the sequential order of this comment within the article (1-based).
CONTEXT is optional code context the comment refers to."
  (let* ((article-id (gnus-reviews--current-article-id))
         (thread-id (gnus-reviews--current-thread-id))
         (comment-id (gnus-reviews--generate-comment-id article-id comment-order))
         (comment-data (list :status status
                             :content comment-text
                             :thread-id thread-id
                             :timestamp (current-time)
                             :context context)))
    (unless article-id
      (error "No article ID available - ensure there is a Gnus article buffer"))
    ;; Add to comment database
    (let ((article-comments (assoc article-id (gnus-reviews--comments))))
      (if article-comments
          (setcdr article-comments
                  (cons (cons comment-id comment-data) (cdr article-comments)))
        (gnus-reviews--store-comments (cons (cons article-id (list (cons comment-id comment-data)))
                                            (gnus-reviews--comments)))))
    comment-id))

(defun gnus-reviews-get-comments-for-article (article-id)
  "Get all tracked comments for ARTICLE-ID."
  (cdr (assoc article-id (gnus-reviews--comments))))

(defun gnus-reviews-update-comment-status (article-id comment-id new-status)
  "Update the status of COMMENT-ID in ARTICLE-ID to NEW-STATUS."
  (when-let ((comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                  (gnus-reviews-get-comments-for-article article-id))))
    (plist-put (cdr comment) :status new-status)
    (gnus-reviews--save-data)))

(defun gnus-reviews-list-pending-comments ()
  "List all pending comments across all articles."
  (let (pending)
    (dolist (article-entry (gnus-reviews--comments))
      (dolist (comment (cdr article-entry))
        (when (eq (plist-get (cdr comment) :status) 'pending)
          (push (list (car comment)           ; comment-id
                      (car article-entry)     ; article-id
                      (plist-get (cdr comment) :status)) ; status
                pending))))
    pending))

(defun gnus-reviews--get-current-patch-series ()
  "Get patch series information for the current context."
  (gnus-with-article-buffer
    (let* ((thread-id (gnus-reviews--current-thread-id))
           (patch-info (gnus-reviews-extract-patch-info)))
      (when patch-info
        (list :thread-id thread-id
              :subject (plist-get patch-info :subject)
              :series-total (plist-get patch-info :series-total)
              :version (plist-get patch-info :version))))))

(defun gnus-reviews-get-series-comments (series-info)
  "Get all comments related to a patch series."
  (when series-info
    (let* ((thread-id (plist-get series-info :thread-id))
           (series-comments '()))
      (dolist (article-entry (gnus-reviews--comments))
        (dolist (comment (cdr article-entry))
          (when (string= (plist-get (cdr comment) :thread-id) thread-id)
            (push (cons (car comment) comment) series-comments))))
      series-comments)))

(defun gnus-reviews-list-pending-comments-for-series ()
  "List pending comments for the current patch series only."
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (cl-remove-if-not (lambda (comment) (eq (plist-get (cddr comment) :status) 'pending))
                      series-comments)))

;;; Core Functions

(defun gnus-reviews-classify-message ()
  "Classify the current message and return its type.
Returns one of: `own-patch', `review-comment', `patch', `other'."
  (cond
   ((and (gnus-reviews-is-patch-email-p) (gnus-reviews-is-own-patch-email-p))
    'own-patch)
   ((gnus-reviews-is-review-email-p)
    'review-comment)
   ((gnus-reviews-is-patch-email-p)
    'patch)
   (t 'other)))

;;; Public Interface

;;;###autoload
(defun gnus-reviews-add-reviewed-by-tag ()
  "Insert a Reviewed-by tag with user's name and email at point."
  (interactive)
  (let ((name (gnus-reviews--get-user-name))
        (email (gnus-reviews--get-user-email)))
    (if (and name email)
        (insert (format "Reviewed-by: %s <%s>\n" name email))
      (message "User name or email not configured. See `gnus-reviews-user-name' and `gnus-reviews-user-email'."))))

;;;###autoload
(defun gnus-reviews-copy-to-group (&optional group)
  "Copy current article to GROUP.
When called interactively, automatically suggests an appropriate group
based on message classification but always asks for confirmation."
  (interactive
   (let* ((type (gnus-reviews-classify-message))
          (default-group (pcase type
                          ('own-patch gnus-reviews-own-patches-group)
                          ('review-comment gnus-reviews-to-review-group)
                          ('patch gnus-reviews-to-review-group)
                          (_ gnus-reviews-to-review-group)))
          (all-groups (list gnus-reviews-own-patches-group
                            gnus-reviews-to-review-group
                            gnus-reviews-watching-group
                            gnus-reviews-finished-group)))
     (list (completing-read
            (format "Copy to group (default %s): " default-group)
            all-groups nil t nil nil default-group))))
  (gnus-reviews--ensure-groups)
  (gnus-summary-copy-article nil group)
  (message "Copied article to %s" group))

;;;###autoload
(defun gnus-reviews-watch-thread ()
  "Watch the current thread by copying all thread articles to watching group.
Also increases the score for the thread to boost visibility."
  (interactive)
  (gnus-reviews--ensure-groups)
  (let ((copied-count 0)
        (thread-articles '())
        (current-article (gnus-summary-article-number)))
    ;; Get all articles in the current thread
    (when current-article
      (save-excursion
        ;; Move to the thread root
        (gnus-summary-refer-thread)
        (gnus-summary-top-thread)
        ;; Collect all thread articles
        (let ((start-point (point)))
          (gnus-summary-down-thread 999999) ; Go to end of thread
          (let ((end-point (point)))
            ;; Go back to start and collect all article numbers
            (goto-char start-point)
            (while (<= (point) end-point)
              (when-let ((article-num (gnus-summary-article-number)))
                (push article-num thread-articles))
              (forward-line 1))))))
    ;; Copy each article in the thread to watching group
    (when thread-articles
      (dolist (article-num (nreverse thread-articles))
        (when (gnus-summary-goto-article article-num)
          ;; Tick the article before copying to preserve the tick status
          (gnus-summary-mark-article nil gnus-ticked-mark)
          (gnus-summary-copy-article nil gnus-reviews-watching-group)
          (cl-incf copied-count))))
    ;; Return to original article and increase score
    (when current-article
      (gnus-summary-goto-article current-article)
      (gnus-reviews-increase-score))
    (message "Watched thread: copied %d articles to %s"
             copied-count gnus-reviews-watching-group)))

;;;###autoload
(defun gnus-reviews-process-my-patch-review ()
  "Process a review of your own patch.
Extracts and tracks individual comments, ticks the article if there are
pending comments, and copies it to the own patches group for follow-up."
  (interactive)
  (unless (gnus-reviews-is-review-email-p)
    (error "Current article is not a review email"))
  (gnus-reviews--ensure-groups)
  ;; Extract and track comments from the review
  (gnus-reviews-extract-and-track-comments)
  ;; Increase score for the subthread to boost visibility
  (gnus-reviews-increase-score)
  ;; Check for pending comments and tick only if found
  (let* ((article-id (gnus-reviews--current-article-id))
         (tracked-comments (gnus-reviews-get-comments-for-article article-id))
         (pending-count (cl-count-if (lambda (comment)
                                      (eq (plist-get (cdr comment) :status) 'pending))
                                    tracked-comments))
         (total-count (length tracked-comments)))
    ;; Tick the article only if there are pending comments
    (when (> pending-count 0)
      (gnus-summary-mark-article nil gnus-ticked-mark))
    ;; Copy to own patches group
    (gnus-summary-copy-article nil gnus-reviews-own-patches-group)
    ;; Show feedback about what was processed
    (cond
     ((> pending-count 0)
      (message "Processed patch review: %d pending comments (of %d total), ticked and copied to %s"
               pending-count total-count gnus-reviews-own-patches-group))
     ((> total-count 0)
      (message "Processed patch review: %d comments tracked (none pending), copied to %s"
               total-count gnus-reviews-own-patches-group))
     (t
      (message "Processed patch review: no comments found, copied to %s"
               gnus-reviews-own-patches-group)))))

;;;###autoload
(defun gnus-reviews-increase-score ()
  "Increase score for the current review-related article subthread and subject.
Temporarily boosts the score of all articles in the subthread starting from
the current article and all articles with the same core subject (prefixes stripped)."
  (interactive)
  (when (or (gnus-reviews-is-patch-email-p)
            (gnus-reviews-is-review-email-p))
    (let ((article-id (gnus-reviews--current-article-id))
          (subject (gnus-with-article-buffer (gnus-fetch-field "Subject")))
          (score gnus-reviews-score-increase)
          (parts '()))
      ;; Score the subthread starting with current article
      (when article-id
        (gnus-summary-score-entry "thread" article-id 's score (current-time-string))
        (push "subthread" parts))
      ;; Score by cleaned subject (strip common prefixes)
      (when subject
        (let ((clean-subject (replace-regexp-in-string
                              "^\\(\\(Re: \\|Fwd: \\)*\\[\\(PATCH\\|RFC\\)[^]]*\\]\\s-*\\|\\(Re: \\|Fwd: \\)+\\)"
                              "" subject)))
          (when (> (length clean-subject) 0)
            (gnus-summary-score-entry "subject" clean-subject 's score (current-time-string))
            (push (format "subject '%s'" clean-subject) parts))))
      ;; Refresh the summary and show single message
      (gnus-summary-rescore)
      (when parts
        (message "Boosted %s score by %d" (string-join (nreverse parts) " and ") score)))))

;;;###autoload
(defun gnus-reviews-extract-and-track-comments ()
  "Extract individual comments from current article and assign status to each."
  (interactive)
  (when (gnus-reviews-is-review-email-p)
    (let ((comments (gnus-reviews--parse-individual-comments))
          (tracked-count 0)
          (status-choices '("pending" "addressed" "dismissed" "skip")))
      (if comments
          (progn
            (message "Found %d individual comments to process..." (length comments))
            (let ((comment-order 1))
              (dolist (comment comments)
                (let* ((text (nth 0 comment))
                       (context (nth 3 comment))
                       (display-text (if context
                                         (format "Context: %s\nComment: %s"
                                                 context
                                                 (substring text 0 (min 100 (length text))))
                                       (substring text 0 (min 100 (length text)))))
                       (status (completing-read
                                (format "Status for comment: %s\n> " display-text)
                                status-choices nil t)))
                  (unless (string= status "skip")
                    (gnus-reviews-track-individual-comment text (intern status) comment-order context)
                    (cl-incf tracked-count))
                  (cl-incf comment-order))))
            (gnus-reviews-increase-score)
            (message "Tracked %d individual comments" tracked-count))
        (message "No individual comments found in this article")))))

;;;###autoload
(defun gnus-reviews-mark-region-as-comment (start end status)
  "Mark the selected region as an individual comment.
START and END define the region.
STATUS should be one of: pending, addressed, dismissed."
  (interactive (list (region-beginning)
                     (region-end)
                     (completing-read "Comment status: "
                                      '("pending" "addressed" "dismissed")
                                      nil t)))
  (let* ((status-symbol (intern status))
         (comment-text (buffer-substring-no-properties start end))
         (all-comments (gnus-reviews--parse-individual-comments))
         (comment-order (1+ (cl-position-if (lambda (comment)
                                              (>= start (nth 1 comment)))
                                            all-comments
                                            :from-end t)))
         (comment-id (gnus-reviews-track-individual-comment
                      comment-text status-symbol comment-order nil)))
    (message "Tracked comment %s as %s: %s"
             comment-id status
             (substring comment-text 0 (min 50 (length comment-text))))))

;;;###autoload
(defun gnus-reviews-mark-comment-addressed ()
  "Mark a comment as addressed, considering current patch series context."
  (interactive)
  (if-let ((pending-comments (gnus-reviews-list-pending-comments-for-series)))
      (let* ((comment-choices (mapcar (lambda (comment)
                                        (let ((content (plist-get (cddr comment) :content)))
                                          (cons (format "%s: %s"
                                                        (car comment)
                                                        (if content
                                                            (substring content 0 (min 50 (length content)))
                                                          "No content"))
                                                (car comment))))
                                      pending-comments))
             (choice (completing-read "Mark comment as addressed: " comment-choices))
             (comment-id (cdr (assoc choice comment-choices))))
        (gnus-reviews-update-comment-status
         (car (split-string comment-id "#")) comment-id 'addressed)
        (message "Marked comment %s as addressed" comment-id))
    (message "No pending comments found for this patch series")))

;;;###autoload
(defun gnus-reviews-change-comment-status ()
  "Change the status of a comment to an interactively selected value."
  (interactive)
  (if-let ((all-comments (gnus-reviews-get-series-comments
                          (gnus-reviews--get-current-patch-series))))
      (let* ((comment-choices (mapcar (lambda (comment)
                                        (let* ((comment-data (cddr comment)) ; series comments have extra nesting
                                               (content (plist-get comment-data :content))
                                               (current-status (plist-get comment-data :status)))
                                          (cons (format "%s [%s]: %s"
                                                        (car comment)
                                                        current-status
                                                        (if content
                                                            (substring content 0 (min 50 (length content)))
                                                          "No content"))
                                                (car comment))))
                                      all-comments))
             (choice (completing-read "Change status for comment: " comment-choices))
             (comment-id (cdr (assoc choice comment-choices)))
             (new-status (completing-read "New status: "
                                         '("pending" "addressed" "dismissed")
                                         nil t)))
        (gnus-reviews-update-comment-status
         (car (split-string comment-id "#")) comment-id (intern new-status))
        (message "Changed comment %s status to %s" comment-id new-status))
    (message "No comments found for current context")))

;;;###autoload
(defun gnus-reviews-show-series-comments ()
  "Show all comments for the current patch series."
  (interactive)
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (if series-comments
        (with-output-to-temp-buffer "*Gnus Reviews: Series Comments*"
          (princ (format "Comments for patch series: %s\n"
                         (or (plist-get series-info :subject) "Unknown")))
          (princ "========================================\n\n")
          (dolist (comment series-comments)
            (let ((status (plist-get (cddr comment) :status))
                  (content (plist-get (cddr comment) :content))
                  (context (plist-get (cddr comment) :context))
                  (timestamp (plist-get (cddr comment) :timestamp)))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 200 (length content)))
                               "No content"))))))
      (message "No comments found for current patch series"))))

;;;###autoload
(defun gnus-reviews-show-article-comments ()
  "Show all individual comments for the current article."
  (interactive)
  (let* ((article-id (gnus-reviews--current-article-id))
         (comments (gnus-reviews-get-comments-for-article article-id)))
    (if comments
        (with-output-to-temp-buffer "*Gnus Reviews: Article Comments*"
          (princ (format "Individual comments for article: %s\n" article-id))
          (princ "==========================================\n\n")
          (dolist (comment comments)
            (let ((status (plist-get (cdr comment) :status))
                  (content (plist-get (cdr comment) :content))
                  (context (plist-get (cdr comment) :context))
                  (timestamp (plist-get (cdr comment) :timestamp)))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 300 (length content)))
                               "No content"))))))
      (message "No individual comments found for current article"))))

;;;###autoload
(defun gnus-reviews-prune-old-reviews ()
  "Remove old completed/dismissed reviews older than specified days.
Uses `gnus-reviews-auto-expire-days' as the cutoff age.
Keeps all pending comments regardless of age."
  (interactive)
  (let ((cutoff-time (time-subtract (current-time)
                                    (days-to-time gnus-reviews-auto-expire-days)))
        (removed-count 0))
    ;; Remove only old completed/dismissed comments, keep pending ones
    (gnus-reviews--store-comments
     (cl-remove-if
      (lambda (entry) (null (cdr entry)))
      (mapcar (lambda (article-entry)
                (cons (car article-entry)
                      (cl-remove-if (lambda (comment)
                                      (let ((comment-time (plist-get (cdr comment) :timestamp))
                                            (status (plist-get (cdr comment) :status)))
                                        (when (and comment-time
                                                   (time-less-p comment-time cutoff-time)
                                                   (memq status '(addressed dismissed)))
                                          (cl-incf removed-count)
                                          t)))
                                    (cdr article-entry))))
              (gnus-reviews--comments))))
    (message "Removed %d old completed comments (kept %d pending ones)"
             removed-count
             (length (gnus-reviews-list-pending-comments)))))

;; Provide the package
(provide 'gnus-reviews)

;;; gnus-reviews.el ends here
