;;; gnus-reviews.el --- Email-based code review management for Gnus  -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Red Hat, Inc.

;; Author: Claude Code <noreply@anthropic.com>
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1") (gnus "5.13"))
;; Keywords: mail, gnus, code-review, development
;; URL: https://github.com/mz-pdm/gnus-reviews
;; Homepage: https://github.com/mz-pdm/gnus-reviews

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package provides tools for managing email-based code reviews in Gnus.
;; It helps organize review messages into appropriate groups, track individual
;; comments and their status, and manage the review lifecycle.
;;
;; Main features:
;; - Automatic classification of patch emails vs. review comments
;; - Organization of messages into purpose-specific Gnus groups
;; - Comment tracking and status management
;; - Review pruning and cleanup
;; - Score boosting for review-relevant articles
;;
;; While designed with libcamera development in mind, this package is generic
;; and can be used with any email-based code review workflow.

;;; Code:

(require 'gnus)
(require 'gnus-sum)
(require 'gnus-art)
(require 'gnus-score)
(require 'gnus-group)
(require 'message)
(require 'cl-lib)

;;; Constants and Variables

(defgroup gnus-reviews nil
  "Email-based code review management for Gnus."
  :group 'gnus
  :prefix "gnus-reviews-")

(defcustom gnus-reviews-base-group "nnml:reviews"
  "Base group name for review-related messages."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-own-patches-group (concat gnus-reviews-base-group ".patches")
  "Group for reviews of your own patches."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-to-review-group (concat gnus-reviews-base-group ".reviews")
  "Group for patches you intend to review."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-watching-group (concat gnus-reviews-base-group ".watching")
  "Group for patches you want to watch without reviewing."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-finished-group (concat gnus-reviews-base-group ".finished")
  "Group for completed reviews."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-score-increase 1000
  "Score increase for review-relevant articles."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-expire-days 30
  "Number of days after which completed reviews are auto-expired."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-data-file "~/.emacs.d/gnus-reviews-data.el"
  "File to store persistent review data."
  :type 'file
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-email nil
  "Email address to use for identifying own patches.
If nil, uses `user-mail-address'."
  :type '(choice (const :tag "Use user-mail-address" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-name nil
  "Full name to use for identifying own patches.
If nil, uses `user-full-name'."
  :type '(choice (const :tag "Use user-full-name" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-create-groups t
  "Whether to automatically create review groups if they don't exist."
  :type 'boolean
  :group 'gnus-reviews)

(defvar gnus-reviews-comment-database nil
  "Database of tracked review comments.
Format: ((message-id . ((comment-id . comment-plist) ...)) ...)
where comment-plist is (:status status :content content :thread-id thread-id :timestamp timestamp :context context)")

(defvar gnus-reviews--initialized nil
  "Non-nil if gnus-reviews has been initialized.")

;;; Data Persistence Functions

(defun gnus-reviews--save-data ()
  "Save review data to persistent storage."
  (when gnus-reviews-data-file
    (condition-case err
        (with-temp-file gnus-reviews-data-file
          (insert ";; Gnus Reviews Data File\n")
          (insert ";; This file is automatically generated. Do not edit manually.\n\n")
          (insert "(setq gnus-reviews-comment-database\n")
          (prin1 gnus-reviews-comment-database (current-buffer))
          (insert ")\n"))
      (error
       (message "Error saving gnus-reviews data: %s" (error-message-string err))))))

(defun gnus-reviews--load-data ()
  "Load review data from persistent storage."
  (when (and gnus-reviews-data-file (file-exists-p gnus-reviews-data-file))
    (condition-case err
        (load gnus-reviews-data-file t t)
      (error
       (message "Error loading gnus-reviews data: %s" (error-message-string err))
       (setq gnus-reviews-comment-database nil)))))

;;; Group Management Functions

(defun gnus-reviews--group-exists-p (group)
  "Check if GROUP exists in Gnus."
  (and group (gnus-group-entry group)))

(defun gnus-reviews--create-group (group)
  "Create GROUP if it doesn't exist and auto-creation is enabled."
  (when (and gnus-reviews-auto-create-groups
             group
             (not (gnus-reviews--group-exists-p group)))
    (condition-case err
        (progn
          (gnus-group-make-group (gnus-group-short-name group) "nnml" "")
          (message "Created review group: %s" group)
          t)
      (error
       (message "Error creating group %s: %s" group (error-message-string err))
       nil))))

(defun gnus-reviews--ensure-groups ()
  "Ensure all review groups exist, creating them if necessary."
  (unless (and (boundp 'gnus-group-buffer)
               gnus-group-buffer
               (get-buffer gnus-group-buffer))
    (error "Gnus group buffer is not available - ensure Gnus is running"))
  (with-current-buffer gnus-group-buffer
    (mapc #'gnus-reviews--create-group
          (list gnus-reviews-base-group
                gnus-reviews-own-patches-group
                gnus-reviews-to-review-group
                gnus-reviews-watching-group
                gnus-reviews-finished-group))))

;;; Validation and Initialization Functions

(defun gnus-reviews--validate-config ()
  "Validate the current configuration."
  (let ((errors '()))
    ;; Check if required groups are configured
    (dolist (var '(gnus-reviews-own-patches-group
                   gnus-reviews-to-review-group
                   gnus-reviews-watching-group
                   gnus-reviews-finished-group))
      (unless (and (boundp var) (symbol-value var) (stringp (symbol-value var)))
        (push (format "%s is not properly configured" var) errors)))

    ;; Check if Gnus is available
    (unless (featurep 'gnus)
      (push "Gnus is not available" errors))

    ;; Return validation results
    (if errors
        (progn
          (message "Gnus-reviews configuration errors: %s" (string-join errors "; "))
          nil)
      t)))

(defun gnus-reviews--get-user-email ()
  "Get the user's email address for patch identification."
  (or gnus-reviews-user-email user-mail-address))

(defun gnus-reviews--get-user-name ()
  "Get the user's full name for patch identification."
  (or gnus-reviews-user-name user-full-name))

;;;###autoload
(defun gnus-reviews-initialize ()
  "Initialize the gnus-reviews package."
  (interactive)
  (unless gnus-reviews--initialized
    (when (gnus-reviews--validate-config)
      (gnus-reviews--load-data)
      (gnus-reviews--ensure-groups)
      (add-hook 'kill-emacs-hook #'gnus-reviews--save-data)
      (setq gnus-reviews--initialized t)
      (message "Gnus Reviews initialized successfully"))))

;;; Utility Functions

(defun gnus-reviews--article-header (func field)
  (cond
   ;; Try to get from article buffer context first (most reliable)
   ((and (boundp 'gnus-current-headers) gnus-current-headers)
    (funcall func gnus-current-headers))
   ;; Try getting from article buffer if we're in one
   ((gnus-buffer-live-p gnus-article-buffer)
    (with-current-buffer gnus-article-buffer
      (when (and (boundp 'gnus-current-headers) gnus-current-headers)
        (funcall func gnus-current-headers))))
   ;; Fall back to summary buffer approach
   ((and (gnus-summary-article-number)
         (gnus-summary-article-header))
    (funcall func (gnus-summary-article-header)))
   ;; Last resort: try to extract from raw article headers
   (t
    (gnus-with-article-headers
      (gnus-fetch-field field)))))

(defun gnus-reviews--current-article-id ()
  "Return the Message-ID of the current article."
  (gnus-reviews--article-header #'mail-header-id "Message-ID"))

(defun gnus-reviews--current-thread-id ()
  "Get the thread ID of the current article.
Uses References headers to determine thread membership."
  (when-let ((refs (gnus-reviews--article-header #'mail-header-references "References")))
    (unless (equal refs "")
      (car (split-string refs " ")))))

;;; Message Classification

(defcustom gnus-reviews-patch-patterns
  '("^\\[PATCH[^]]*\\]" "^\\[RFC[^]]*\\]" "^diff --git" "^---.*\\+\\+\\+" "^Index: ")
  "Patterns that indicate a message contains a patch."
  :type '(repeat string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-review-patterns
  '("^Re:.*\\[PATCH" "^Re:.*\\[RFC" "Reviewed-by:" "Acked-by:" "Tested-by:"
    "^On .* wrote:" "> .*" "inline comment")
  "Patterns that indicate a message is a review comment."
  :type '(repeat string)
  :group 'gnus-reviews)

(defun gnus-reviews--match-patterns (content patterns)
  "Check if CONTENT matches any of the PATTERNS."
  (cl-some (lambda (pattern)
             (string-match-p pattern content))
           patterns))

(defun gnus-reviews-is-patch-email-p ()
  "Return non-nil if current article is a patch email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string)))
      (or (and subject (gnus-reviews--match-patterns subject gnus-reviews-patch-patterns))
          (gnus-reviews--match-patterns content gnus-reviews-patch-patterns)))))

(defun gnus-reviews-is-own-patch-email-p ()
  "Return non-nil if current article is a patch by the user."
  (gnus-with-article-buffer
    (let ((from (gnus-fetch-field "From"))
          (user-email (gnus-reviews--get-user-email))
          (user-name (gnus-reviews--get-user-name)))
      (and from
           (or (and user-email (string-match (regexp-quote user-email) from))
               (and user-name (string-match (regexp-quote user-name) from)))
           (gnus-reviews-is-patch-email-p)))))

(defun gnus-reviews-is-review-email-p ()
  "Return non-nil if current article is a review email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string))
          (in-reply-to (gnus-fetch-field "In-Reply-To")))
      (and subject
           (not (gnus-reviews-is-patch-email-p))
           (or in-reply-to (string-match "^Re:" subject))
           (or (gnus-reviews--match-patterns subject gnus-reviews-review-patterns)
               (gnus-reviews--match-patterns content gnus-reviews-review-patterns))))))

(defun gnus-reviews-extract-patch-info ()
  "Extract patch information from the current article.
Returns a plist with :series-num, :series-total, :version, :subject."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject")))
      (when subject
        (cond
         ;; PATCH series with version and series numbers
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))))
         ;; RFC series with version and series numbers
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))
                :rfc t))
         ;; Single PATCH with version
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))))
         ;; Single RFC with version
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))
                :rfc t)))))))

;;; Comment Tracking System

(defun gnus-reviews--generate-comment-id (article-id comment-order)
  "Generate a deterministic unique comment ID.
ARTICLE-ID identifies the article, COMMENT-ORDER is the sequential order
of this comment within the article (1-based)."
  (format "%s#%d" article-id comment-order))

(defun gnus-reviews--parse-individual-comments ()
  "Parse individual review comments from current article.
Returns a list of (content start-pos end-pos context) for each comment."
  (gnus-with-article-buffer
    (let ((content (buffer-string))
          (comments '())
          (body-start 0))
      ;; Skip headers
      (when (string-match "\n\n" content)
        (setq body-start (match-end 0)))

      (with-temp-buffer
        (insert (substring content body-start))
        (goto-char (point-min))

        (let ((current-context nil)
              (comment-lines '())
              (comment-start-pos nil))

          (while (not (eobp))
            (cond
             ;; Found quoted line - save any accumulated comment block first
             ((looking-at "^> \\(.+\\)$")
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))
              ;; Update context for future comments
              (setq current-context (match-string-no-properties 1)))

             ;; Found non-quoted, non-empty line
             ((looking-at "^\\([^>\n].*\\)$")
              (let ((line-text (save-match-data (string-trim (match-string-no-properties 1)))))
                ;; Exclude signature lines, headers, but include actual comment content
                (when (and (> (length line-text) 0)
                           (string-match "\\w" line-text)
                           (not (string-match "^\\(On \\|--\\|___\\|From:\\|Subject:\\)" line-text)))
                  (when (null comment-start-pos)
                    (setq comment-start-pos (line-beginning-position)))
                  (push line-text comment-lines))))

             ;; Empty line or other - save accumulated comment block if any
             (t
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))))

            (forward-line 1))

          ;; Handle any remaining comment block at end of buffer
          (when comment-lines
            (let ((comment-text (string-join (nreverse comment-lines) "\n")))
              (when (and (> (length comment-text) 0)
                         (string-match "\\w" comment-text))
                (push (list comment-text
                            (+ body-start comment-start-pos)
                            (+ body-start (point-max))
                            current-context)
                      comments))))))

      (nreverse comments))))

(defun gnus-reviews-track-individual-comment (comment-text status comment-order &optional context)
  "Track an individual review comment.
COMMENT-TEXT is the actual comment content.
STATUS should be one of: `pending', `addressed', `dismissed'.
COMMENT-ORDER is the sequential order of this comment within the article (1-based).
CONTEXT is optional code context the comment refers to."
  (let* ((article-id (gnus-reviews--current-article-id))
         (thread-id (gnus-reviews--current-thread-id))
         (comment-id (gnus-reviews--generate-comment-id article-id comment-order))
         (comment-data (list :status status
                             :content comment-text
                             :thread-id thread-id
                             :timestamp (current-time)
                             :context context)))
    (unless article-id
      (error "No article ID available - ensure there is a Gnus article buffer"))
    ;; Add to comment database
    (let ((article-comments (assoc article-id gnus-reviews-comment-database)))
      (if article-comments
          (setcdr article-comments
                  (cons (cons comment-id comment-data) (cdr article-comments)))
        (push (cons article-id (list (cons comment-id comment-data)))
              gnus-reviews-comment-database)))
    ;; Save data
    (gnus-reviews--save-data)
    comment-id))

(defun gnus-reviews-get-comments-for-article (article-id)
  "Get all tracked comments for ARTICLE-ID."
  (cdr (assoc article-id gnus-reviews-comment-database)))

(defun gnus-reviews-update-comment-status (comment-id new-status)
  "Update the status of COMMENT-ID to NEW-STATUS."
  (catch 'found
    (dolist (article-entry gnus-reviews-comment-database)
      (dolist (comment (cdr article-entry))
        (when (string= (car comment) comment-id)
          (plist-put (cdr comment) :status new-status)
          (gnus-reviews--save-data)
          (throw 'found t))))))

(defun gnus-reviews-list-pending-comments ()
  "List all pending comments across all articles."
  (let (pending)
    (dolist (article-entry gnus-reviews-comment-database)
      (dolist (comment (cdr article-entry))
        (when (eq (plist-get (cdr comment) :status) 'pending)
          (push (list (car comment)           ; comment-id
                      (car article-entry)     ; article-id
                      (plist-get (cdr comment) :status)) ; status
                pending))))
    pending))

(defun gnus-reviews--get-current-patch-series ()
  "Get patch series information for the current context."
  (gnus-with-article-buffer
    (let* ((thread-id (gnus-reviews--current-thread-id))
           (patch-info (gnus-reviews-extract-patch-info)))
      (when patch-info
        (list :thread-id thread-id
              :subject (plist-get patch-info :subject)
              :series-total (plist-get patch-info :series-total)
              :version (plist-get patch-info :version))))))

(defun gnus-reviews-get-series-comments (series-info)
  "Get all comments related to a patch series."
  (when series-info
    (let* ((thread-id (plist-get series-info :thread-id))
           (series-comments '()))
      (dolist (article-entry gnus-reviews-comment-database)
        (dolist (comment (cdr article-entry))
          (when (string= (plist-get (cdr comment) :thread-id) thread-id)
            (push (cons (car comment) comment) series-comments))))
      series-comments)))

(defun gnus-reviews-list-pending-comments-for-series ()
  "List pending comments for the current patch series only."
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (cl-remove-if-not (lambda (comment) (eq (plist-get (cdr comment) :status) 'pending))
                      series-comments)))

;;; Core Functions

(defun gnus-reviews-classify-message ()
  "Classify the current message and return its type.
Returns one of: `own-patch', `review-comment', `patch', `other'."
  (cond
   ((and (gnus-reviews-is-patch-email-p) (gnus-reviews-is-own-patch-email-p))
    'own-patch)
   ((gnus-reviews-is-review-email-p)
    'review-comment)
   ((gnus-reviews-is-patch-email-p)
    'patch)
   (t 'other)))

;;; Public Interface

;;;###autoload
(defun gnus-reviews-add-reviewed-by-tag ()
  "Insert a 'Reviewed-by' tag with user's name and email at point."
  (interactive)
  (let ((name (gnus-reviews--get-user-name))
        (email (gnus-reviews--get-user-email)))
    (if (and name email)
        (insert (format "Reviewed-by: %s <%s>\n" name email))
      (message "User name or email not configured. See `gnus-reviews-user-name' and `gnus-reviews-user-email'."))))

;;;###autoload
(defun gnus-reviews-copy-to-group (&optional group)
  "Copy current article to GROUP.
When called interactively, automatically suggests an appropriate group
based on message classification but always asks for confirmation."
  (interactive
   (let* ((type (gnus-reviews-classify-message))
          (default-group (pcase type
                          ('own-patch gnus-reviews-own-patches-group)
                          ('review-comment gnus-reviews-to-review-group)
                          ('patch gnus-reviews-to-review-group)
                          (_ gnus-reviews-to-review-group)))
          (all-groups (list gnus-reviews-own-patches-group
                            gnus-reviews-to-review-group
                            gnus-reviews-watching-group
                            gnus-reviews-finished-group)))
     (list (completing-read
            (format "Copy to group (default %s): " default-group)
            all-groups nil t nil nil default-group))))
  (gnus-summary-copy-article nil group)
  (message "Copied article to %s" group))

;;;###autoload
(defun gnus-reviews-increase-score ()
  "Increase score for the current review-related article subthread and subject.
Temporarily boosts the score of all articles in the subthread starting from
the current article and all articles with the same core subject (prefixes stripped)."
  (interactive)
  (when (or (gnus-reviews-is-patch-email-p)
            (gnus-reviews-is-review-email-p))
    (let ((article-id (gnus-reviews--current-article-id))
          (subject (gnus-with-article-buffer (gnus-fetch-field "Subject")))
          (score gnus-reviews-score-increase)
          (time (time-to-days (current-time)))
          (parts '()))
      ;; Score the subthread starting with current article
      (when article-id
        (gnus-summary-score-entry "thread" article-id 's score (current-time-string))
        (push "subthread" parts))
      ;; Score by cleaned subject (strip common prefixes)
      (when subject
        (let ((clean-subject (replace-regexp-in-string
                              "^\\(\\(Re: \\|Fwd: \\)*\\[\\(PATCH\\|RFC\\)[^]]*\\]\\s-*\\|\\(Re: \\|Fwd: \\)+\\)"
                              "" subject)))
          (when (> (length clean-subject) 0)
            (gnus-summary-score-entry "subject" clean-subject 's score (current-time-string))
            (push (format "subject '%s'" clean-subject) parts))))
      ;; Refresh the summary and show single message
      (gnus-summary-rescore)
      (when parts
        (message "Boosted %s score by %d" (string-join (nreverse parts) " and ") score)))))

;;;###autoload
(defun gnus-reviews-extract-and-track-comments ()
  "Extract individual comments from current article and assign status to each."
  (interactive)
  (when (gnus-reviews-is-review-email-p)
    (let ((comments (gnus-reviews--parse-individual-comments))
          (tracked-count 0)
          (status-choices '("pending" "addressed" "dismissed" "skip")))
      (if comments
          (progn
            (message "Found %d individual comments to process..." (length comments))
            (let ((comment-order 1))
              (dolist (comment comments)
                (let* ((text (nth 0 comment))
                       (context (nth 3 comment))
                       (display-text (if context
                                         (format "Context: %s\nComment: %s"
                                                 context
                                                 (substring text 0 (min 100 (length text))))
                                       (substring text 0 (min 100 (length text)))))
                       (status (completing-read
                                (format "Status for comment: %s\n> " display-text)
                                status-choices nil t)))
                  (unless (string= status "skip")
                    (gnus-reviews-track-individual-comment text (intern status) comment-order context)
                    (cl-incf tracked-count))
                  (cl-incf comment-order))))
            (gnus-reviews-increase-score)
            (message "Tracked %d individual comments" tracked-count))
        (message "No individual comments found in this article")))))

;;;###autoload
(defun gnus-reviews-mark-region-as-comment (start end status)
  "Mark the selected region as an individual comment.
START and END define the region.
STATUS should be one of: pending, addressed, dismissed."
  (interactive "r\nsComment status (pending/addressed/dismissed): ")
  (let* ((status-symbol (intern status))
         (comment-text (buffer-substring-no-properties start end))
         (all-comments (gnus-reviews--parse-individual-comments))
         (comment-order (1+ (cl-position-if (lambda (comment)
                                              (>= start (nth 1 comment)))
                                            all-comments
                                            :from-end t)))
         (comment-id (gnus-reviews-track-individual-comment
                      comment-text status-symbol comment-order nil)))
    (message "Tracked comment %s as %s: %s"
             comment-id status
             (substring comment-text 0 (min 50 (length comment-text))))))

;;;###autoload
(defun gnus-reviews-mark-comment-addressed ()
  "Mark a comment as addressed, considering current patch series context."
  (interactive)
  (let* ((series-comments (gnus-reviews-list-pending-comments-for-series))
         (pending-comments (if series-comments
                               series-comments
                             ;; Fall back to article-specific comments
                             (let ((article-comments (gnus-reviews-get-comments-for-article
                                                      (gnus-reviews--current-article-id))))
                               (cl-remove-if-not
                                (lambda (comment) (eq (plist-get (cdr comment) :status) 'pending))
                                article-comments)))))
    (if pending-comments
        (let* ((comment-choices (mapcar (lambda (comment)
                                          (let ((content (plist-get (cdr comment) :content)))
                                            (cons (format "%s: %s"
                                                          (car comment)
                                                          (if content
                                                              (substring content 0 (min 50 (length content)))
                                                            "No content"))
                                                  (car comment))))
                                        pending-comments))
               (choice (completing-read "Mark comment as addressed: " comment-choices))
               (comment-id (cdr (assoc choice comment-choices))))
          (gnus-reviews-update-comment-status comment-id 'addressed)
          (message "Marked comment %s as addressed" comment-id))
      (message "No pending comments found for this patch series"))))

;;;###autoload
(defun gnus-reviews-show-series-comments ()
  "Show all comments for the current patch series."
  (interactive)
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (if series-comments
        (with-output-to-temp-buffer "*Gnus Reviews: Series Comments*"
          (princ (format "Comments for patch series: %s\n"
                         (or (plist-get series-info :subject) "Unknown")))
          (princ "========================================\n\n")
          (dolist (comment series-comments)
            (let ((status (plist-get (cdr comment) :status))
                  (content (plist-get (cdr comment) :content))
                  (context (plist-get (cdr comment) :context))
                  (timestamp (plist-get (cdr comment) :timestamp)))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 200 (length content)))
                               "No content"))))))
      (message "No comments found for current patch series"))))

;;;###autoload
(defun gnus-reviews-show-article-comments ()
  "Show all individual comments for the current article."
  (interactive)
  (let* ((article-id (gnus-reviews--current-article-id))
         (comments (gnus-reviews-get-comments-for-article article-id)))
    (if comments
        (with-output-to-temp-buffer "*Gnus Reviews: Article Comments*"
          (princ (format "Individual comments for article: %s\n" article-id))
          (princ "==========================================\n\n")
          (dolist (comment comments)
            (let ((status (plist-get (cdr comment) :status))
                  (content (plist-get (cdr comment) :content))
                  (context (plist-get (cdr comment) :context))
                  (timestamp (plist-get (cdr comment) :timestamp)))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 300 (length content)))
                               "No content"))))))
      (message "No individual comments found for current article"))))

;;;###autoload
(defun gnus-reviews-prune-old-reviews ()
  "Remove old completed/dismissed reviews older than specified days.
Uses `gnus-reviews-auto-expire-days' as the cutoff age.
Keeps all pending comments regardless of age."
  (interactive)
  (let ((cutoff-time (time-subtract (current-time)
                                    (days-to-time gnus-reviews-auto-expire-days)))
        (removed-count 0))
    ;; Remove only old completed/dismissed comments, keep pending ones
    (setq gnus-reviews-comment-database
          (mapcar (lambda (article-entry)
                    (cons (car article-entry)
                          (cl-remove-if (lambda (comment)
                                          (let ((comment-time (plist-get (cdr comment) :timestamp))
                                                (status (plist-get (cdr comment) :status)))
                                            (when (and comment-time
                                                       (time-less-p comment-time cutoff-time)
                                                       (memq status '(addressed dismissed)))
                                              (cl-incf removed-count)
                                              t)))
                                        (cdr article-entry))))
                  gnus-reviews-comment-database))
    ;; Remove empty article entries
    (setq gnus-reviews-comment-database
          (cl-remove-if (lambda (entry) (null (cdr entry)))
                        gnus-reviews-comment-database))
    ;; Save changes
    (gnus-reviews--save-data)
    (message "Removed %d old completed comments (kept %d pending ones)"
             removed-count
             (length (gnus-reviews-list-pending-comments)))))

;; Provide the package
(provide 'gnus-reviews)

;;; gnus-reviews.el ends here
