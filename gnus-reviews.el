;;; gnus-reviews.el --- Email-based code review management for Gnus  -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Red Hat, Inc.

;; Author: Claude Code <noreply@anthropic.com>
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1") (gnus "5.13"))
;; Keywords: mail, gnus, code-review, development
;; URL: https://github.com/mz-pdm/gnus-reviews
;; Homepage: https://github.com/mz-pdm/gnus-reviews

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package provides tools for managing email-based code reviews in Gnus.
;; It helps organize review messages into appropriate groups, track individual
;; comments and their status, and manage the review lifecycle.
;;
;; Main features:
;; - Automatic classification of patch emails vs. review comments
;; - Organization of messages into purpose-specific Gnus groups
;; - Comment tracking and status management
;; - Review pruning and cleanup
;; - Score boosting for review-relevant articles
;;
;; While designed with libcamera development in mind, this package is generic
;; and can be used with any email-based code review workflow.

;;; Code:

(require 'gnus)
(require 'gnus-sum)
(require 'gnus-art)
(require 'gnus-score)
(require 'gnus-group)
(require 'message)
(require 'cl-lib)

;;; Constants and Variables

(defgroup gnus-reviews nil
  "Email-based code review management for Gnus."
  :group 'gnus
  :prefix "gnus-reviews-")

(defcustom gnus-reviews-base-group "nnml:reviews"
  "Base group name for review-related messages."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-own-patches-group (concat gnus-reviews-base-group ".patches")
  "Group for reviews of your own patches."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-to-review-group (concat gnus-reviews-base-group ".reviews")
  "Group for patches you intend to review."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-watching-group (concat gnus-reviews-base-group ".watching")
  "Group for patches you want to watch without reviewing."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-finished-group (concat gnus-reviews-base-group ".finished")
  "Group for completed reviews."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-score-increase 1000
  "Score increase for review-relevant articles."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-expire-days 30
  "Number of days after which completed reviews are auto-expired."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-data-file "~/.emacs.d/gnus-reviews-data.el"
  "File to store persistent review data."
  :type 'file
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-email nil
  "Email address to use for identifying own patches.
If nil, uses `user-mail-address'."
  :type '(choice (const :tag "Use user-mail-address" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-name nil
  "Full name to use for identifying own patches.
If nil, uses `user-full-name'."
  :type '(choice (const :tag "Use user-full-name" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-create-groups t
  "Whether to automatically create review groups if they don't exist."
  :type 'boolean
  :group 'gnus-reviews)

(defvar gnus-reviews-comment-database nil
  "Database of tracked review comments.
Format: ((message-id . ((comment-id . (status content thread-id)) ...)) ...)")

(defvar gnus-reviews--initialized nil
  "Non-nil if gnus-reviews has been initialized.")

;;; Data Persistence Functions

(defun gnus-reviews--save-data ()
  "Save review data to persistent storage."
  (when gnus-reviews-data-file
    (condition-case err
        (with-temp-file gnus-reviews-data-file
          (insert ";; Gnus Reviews Data File\n")
          (insert ";; This file is automatically generated. Do not edit manually.\n\n")
          (insert "(setq gnus-reviews-comment-database\n")
          (prin1 gnus-reviews-comment-database (current-buffer))
          (insert ")\n"))
      (error
       (message "Error saving gnus-reviews data: %s" (error-message-string err))))))

(defun gnus-reviews--load-data ()
  "Load review data from persistent storage."
  (when (and gnus-reviews-data-file (file-exists-p gnus-reviews-data-file))
    (condition-case err
        (load gnus-reviews-data-file t t)
      (error
       (message "Error loading gnus-reviews data: %s" (error-message-string err))
       (setq gnus-reviews-comment-database nil)))))

;;; Group Management Functions

(defun gnus-reviews--group-exists-p (group)
  "Check if GROUP exists in Gnus."
  (and group (gnus-group-entry group)))

(defun gnus-reviews--create-group (group)
  "Create GROUP if it doesn't exist and auto-creation is enabled."
  (when (and gnus-reviews-auto-create-groups
             group
             (not (gnus-reviews--group-exists-p group)))
    (condition-case err
        (progn
          (gnus-group-make-group (gnus-group-short-name group) "nnml" "")
          (message "Created review group: %s" group)
          t)
      (error
       (message "Error creating group %s: %s" group (error-message-string err))
       nil))))

(defun gnus-reviews--ensure-groups ()
  "Ensure all review groups exist, creating them if necessary."
  (unless (and (boundp 'gnus-group-buffer)
               gnus-group-buffer
               (get-buffer gnus-group-buffer))
    (error "Gnus group buffer is not available - ensure Gnus is running"))
  (with-current-buffer gnus-group-buffer
    (mapc #'gnus-reviews--create-group
          (list gnus-reviews-base-group
                gnus-reviews-own-patches-group
                gnus-reviews-to-review-group
                gnus-reviews-watching-group
                gnus-reviews-finished-group))))

;;; Validation and Initialization Functions

(defun gnus-reviews--validate-config ()
  "Validate the current configuration."
  (let ((errors '()))
    ;; Check if required groups are configured
    (dolist (var '(gnus-reviews-own-patches-group
                   gnus-reviews-to-review-group
                   gnus-reviews-watching-group
                   gnus-reviews-finished-group))
      (unless (and (boundp var) (symbol-value var) (stringp (symbol-value var)))
        (push (format "%s is not properly configured" var) errors)))

    ;; Check if Gnus is available
    (unless (featurep 'gnus)
      (push "Gnus is not available" errors))

    ;; Return validation results
    (if errors
        (progn
          (message "Gnus-reviews configuration errors: %s" (string-join errors "; "))
          nil)
      t)))

(defun gnus-reviews--get-user-email ()
  "Get the user's email address for patch identification."
  (or gnus-reviews-user-email user-mail-address))

(defun gnus-reviews--get-user-name ()
  "Get the user's full name for patch identification."
  (or gnus-reviews-user-name user-full-name))

;;;###autoload
(defun gnus-reviews-initialize ()
  "Initialize the gnus-reviews package."
  (interactive)
  (unless gnus-reviews--initialized
    (when (gnus-reviews--validate-config)
      (gnus-reviews--load-data)
      (gnus-reviews--ensure-groups)
      (add-hook 'kill-emacs-hook #'gnus-reviews--save-data)
      (setq gnus-reviews--initialized t)
      (message "Gnus Reviews initialized successfully"))))

;;; Utility Functions

(defun gnus-reviews--current-article-id ()
  "Get the Message-ID of the current article."
  (when (gnus-summary-article-number)
    (gnus-with-article-buffer
      (gnus-fetch-field "Message-ID"))))

(defun gnus-reviews--get-thread-id (article-id)
  "Get the thread ID for ARTICLE-ID.
Uses In-Reply-To and References headers to determine thread membership."
  (gnus-with-article-buffer
    (or (gnus-fetch-field "In-Reply-To")
        (car (split-string (or (gnus-fetch-field "References") "") " "))
        article-id)))

;;; Message Classification

(defcustom gnus-reviews-patch-patterns
  '("^\\[PATCH[^]]*\\]" "^\\[RFC[^]]*\\]" "^diff --git" "^---.*\\+\\+\\+" "^Index: ")
  "Patterns that indicate a message contains a patch."
  :type '(repeat string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-review-patterns
  '("^Re:.*\\[PATCH" "^Re:.*\\[RFC" "Reviewed-by:" "Acked-by:" "Tested-by:"
    "^On .* wrote:" "> .*" "inline comment")
  "Patterns that indicate a message is a review comment."
  :type '(repeat string)
  :group 'gnus-reviews)

(defun gnus-reviews--match-patterns (content patterns)
  "Check if CONTENT matches any of the PATTERNS."
  (cl-some (lambda (pattern)
             (string-match-p pattern content))
           patterns))

(defun gnus-reviews-is-patch-email-p ()
  "Return non-nil if current article is a patch email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string)))
      (or (and subject (gnus-reviews--match-patterns subject gnus-reviews-patch-patterns))
          (gnus-reviews--match-patterns content gnus-reviews-patch-patterns)))))

(defun gnus-reviews-is-own-patch-email-p ()
  "Return non-nil if current article is a patch by the user."
  (gnus-with-article-buffer
    (let ((from (gnus-fetch-field "From"))
          (user-email (gnus-reviews--get-user-email))
          (user-name (gnus-reviews--get-user-name)))
      (and from
           (or (and user-email (string-match (regexp-quote user-email) from))
               (and user-name (string-match (regexp-quote user-name) from)))
           (gnus-reviews-is-patch-email-p)))))

(defun gnus-reviews-is-review-email-p ()
  "Return non-nil if current article is a review email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string))
          (in-reply-to (gnus-fetch-field "In-Reply-To")))
      (and subject
           (not (gnus-reviews-is-patch-email-p))
           (or in-reply-to (string-match "^Re:" subject))
           (or (gnus-reviews--match-patterns subject gnus-reviews-review-patterns)
               (gnus-reviews--match-patterns content gnus-reviews-review-patterns))))))

(defun gnus-reviews-extract-patch-info ()
  "Extract patch information from the current article.
Returns a plist with :series-num, :series-total, :version, :subject."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject")))
      (when subject
        (cond
         ;; PATCH series with version and series numbers
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))))
         ;; RFC series with version and series numbers
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\s-+\\([0-9]+\\)/\\([0-9]+\\)\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))
                :rfc t))
         ;; Single PATCH with version
         ((string-match "\\[PATCH\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))))
         ;; Single RFC with version
         ((string-match "\\[RFC\\(?:\\s-+v\\([0-9]+\\)\\)?\\]\\s-*\\(.*\\)" subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))
                :rfc t)))))))

;;; Comment Tracking System

(defun gnus-reviews--generate-comment-id (article-id comment-order)
  "Generate a deterministic unique comment ID.
ARTICLE-ID identifies the article, COMMENT-ORDER is the sequential order
of this comment within the article (1-based)."
  (format "%s#%d" article-id comment-order))

(defun gnus-reviews--parse-individual-comments ()
  "Parse individual review comments from current article.
Returns a list of (content start-pos end-pos context) for each comment."
  (gnus-with-article-buffer
    (let ((content (buffer-string))
          (comments '())
          (body-start 0))
      ;; Skip headers
      (when (string-match "\n\n" content)
        (setq body-start (match-end 0)))

      (with-temp-buffer
        (insert (substring content body-start))
        (goto-char (point-min))

        (let ((current-context nil)
              (comment-lines '())
              (comment-start-pos nil))

          (while (not (eobp))
            (cond
             ;; Found quoted line - save any accumulated comment block first
             ((looking-at "^> \\(.+\\)$")
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))
              ;; Update context for future comments
              (setq current-context (match-string-no-properties 1)))

             ;; Found non-quoted, non-empty line
             ((looking-at "^\\([^>\n].*\\)$")
              (let ((line-text (save-match-data (string-trim (match-string-no-properties 1)))))
                ;; Exclude signature lines, headers, but include actual comment content
                (when (and (> (length line-text) 0)
                           (string-match "\\w" line-text)
                           (not (string-match "^\\(On \\|--\\|___\\|From:\\|Subject:\\)" line-text)))
                  (when (null comment-start-pos)
                    (setq comment-start-pos (line-beginning-position)))
                  (push line-text comment-lines))))

             ;; Empty line or other - save accumulated comment block if any
             (t
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))))

            (forward-line 1))

          ;; Handle any remaining comment block at end of buffer
          (when comment-lines
            (let ((comment-text (string-join (nreverse comment-lines) "\n")))
              (when (and (> (length comment-text) 0)
                         (string-match "\\w" comment-text))
                (push (list comment-text
                            (+ body-start comment-start-pos)
                            (+ body-start (point-max))
                            current-context)
                      comments))))))

      (nreverse comments))))

(defun gnus-reviews-track-individual-comment (comment-text status comment-order &optional context position)
  "Track an individual review comment.
COMMENT-TEXT is the actual comment content.
STATUS should be one of: `pending', `addressed', `dismissed'.
COMMENT-ORDER is the sequential order of this comment within the article (1-based).
CONTEXT is optional code context the comment refers to.
POSITION is optional buffer position of the comment."
  (let* ((article-id (gnus-reviews--current-article-id))
         (thread-id (gnus-reviews--get-thread-id article-id))
         (comment-id (gnus-reviews--generate-comment-id article-id comment-order))
         (comment-data (list status
                             comment-text
                             thread-id
                             (current-time)
                             context
                             position)))
    (when article-id
      ;; Add to comment database
      (let ((article-comments (assoc article-id gnus-reviews-comment-database)))
        (if article-comments
            (setcdr article-comments
                    (cons (cons comment-id comment-data) (cdr article-comments)))
          (push (cons article-id (list (cons comment-id comment-data)))
                gnus-reviews-comment-database)))
      ;; Save data
      (gnus-reviews--save-data)
      comment-id)))

(defun gnus-reviews-get-comments-for-article (article-id)
  "Get all tracked comments for ARTICLE-ID."
  (cdr (assoc article-id gnus-reviews-comment-database)))

(defun gnus-reviews-update-comment-status (comment-id new-status)
  "Update the status of COMMENT-ID to NEW-STATUS."
  (catch 'found
    (dolist (article-entry gnus-reviews-comment-database)
      (dolist (comment (cdr article-entry))
        (when (string= (car comment) comment-id)
          (setcar (cdr comment) new-status)
          (gnus-reviews--save-data)
          (throw 'found t))))))

(defun gnus-reviews-list-pending-comments ()
  "List all pending comments across all articles."
  (let (pending)
    (dolist (article-entry gnus-reviews-comment-database)
      (dolist (comment (cdr article-entry))
        (when (eq (nth 1 comment) 'pending)
          (push (list (car comment)           ; comment-id
                      (car article-entry)     ; article-id
                      (nth 1 comment))        ; status
                pending))))
    pending))

(defun gnus-reviews--get-current-patch-series ()
  "Get patch series information for the current context."
  (gnus-with-article-buffer
    (let* ((thread-id (gnus-reviews--get-thread-id (gnus-reviews--current-article-id)))
           (patch-info (gnus-reviews-extract-patch-info)))
      (when patch-info
        (list :thread-id thread-id
              :subject (plist-get patch-info :subject)
              :series-total (plist-get patch-info :series-total)
              :version (plist-get patch-info :version))))))

(defun gnus-reviews-get-series-comments (series-info)
  "Get all comments related to a patch series."
  (when series-info
    (let* ((thread-id (plist-get series-info :thread-id))
           (series-comments '()))
      (dolist (article-entry gnus-reviews-comment-database)
        (dolist (comment (cdr article-entry))
          (when (string= (nth 3 comment) thread-id)
            (push (cons (car comment) comment) series-comments))))
      series-comments)))

(defun gnus-reviews-list-pending-comments-for-series ()
  "List pending comments for the current patch series only."
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (cl-remove-if-not (lambda (comment) (eq (nth 1 (cdr comment)) 'pending))
                      series-comments)))

;;; Core Functions

(defun gnus-reviews-classify-message ()
  "Classify the current message and return its type.
Returns one of: `own-patch', `review-comment', `patch', `other'."
  (cond
   ((and (gnus-reviews-is-patch-email-p) (gnus-reviews-is-own-patch-email-p))
    'own-patch)
   ((gnus-reviews-is-review-email-p)
    'review-comment)
   ((gnus-reviews-is-patch-email-p)
    'patch)
   (t 'other)))

;;; Public Interface

;;;###autoload
(defun gnus-reviews-copy-to-group (group)
  "Copy current article to GROUP."
  (interactive
   (list (completing-read "Copy to group: "
                          (list gnus-reviews-own-patches-group
                                gnus-reviews-to-review-group
                                gnus-reviews-watching-group
                                gnus-reviews-finished-group))))
  (gnus-summary-copy-article nil group))

;;;###autoload
(defun gnus-reviews-process-article ()
  "Process the current article based on its classification."
  (interactive)
  (let ((type (gnus-reviews-classify-message))
        (article-id (gnus-reviews--current-article-id)))
    (when article-id
      (pcase type
        ('own-patch
         (gnus-reviews-copy-to-group gnus-reviews-own-patches-group)
         (message "Copied own patch to %s" gnus-reviews-own-patches-group))
        ('review-comment
         (gnus-reviews-copy-to-group gnus-reviews-to-review-group)
         (message "Copied review comment to %s" gnus-reviews-to-review-group))
        ('patch
         (let ((group (completing-read "Copy patch to: "
                                       (list gnus-reviews-to-review-group
                                             gnus-reviews-watching-group))))
           (gnus-reviews-copy-to-group group)
           (message "Copied patch to %s" group)))
        ('other
         (message "Article type: other (no automatic action)"))))))

;;;###autoload
(defun gnus-reviews-increase-score ()
  "Increase score for the current review-related article."
  (interactive)
  (when (or (gnus-reviews-is-patch-email-p)
            (gnus-reviews-is-review-email-p))
    (gnus-summary-increase-score gnus-reviews-score-increase)
    (message "Increased score by %d" gnus-reviews-score-increase)))

;;;###autoload
(defun gnus-reviews-extract-and-track-comments ()
  "Extract individual comments from current article and assign status to each."
  (interactive)
  (when (gnus-reviews-is-review-email-p)
    (let ((comments (gnus-reviews--parse-individual-comments))
          (tracked-count 0)
          (status-choices '("pending" "addressed" "dismissed" "skip")))
      (if comments
          (progn
            (message "Found %d individual comments to process..." (length comments))
            (let ((comment-order 1))
              (dolist (comment comments)
                (let* ((text (nth 0 comment))
                       (context (nth 3 comment))
                       (position (nth 1 comment))
                       (display-text (if context
                                         (format "Context: %s\nComment: %s"
                                                 context
                                                 (substring text 0 (min 100 (length text))))
                                       (substring text 0 (min 100 (length text)))))
                       (status (completing-read
                                (format "Status for comment: %s\n> " display-text)
                                status-choices nil t)))
                  (unless (string= status "skip")
                    (gnus-reviews-track-individual-comment text (intern status) comment-order context position)
                    (cl-incf tracked-count))
                  (cl-incf comment-order))))
            (gnus-reviews-increase-score)
            (message "Tracked %d individual comments" tracked-count))
        (message "No individual comments found in this article")))))

;;;###autoload
(defun gnus-reviews-mark-region-as-comment (start end status)
  "Mark the selected region as an individual comment.
START and END define the region.
STATUS should be one of: pending, addressed, dismissed."
  (interactive "r\nsComment status (pending/addressed/dismissed): ")
  (let* ((status-symbol (intern status))
         (comment-text (buffer-substring-no-properties start end))
         (all-comments (gnus-reviews--parse-individual-comments))
         (comment-order (1+ (cl-position-if (lambda (comment)
                                              (>= start (nth 1 comment)))
                                            all-comments
                                            :from-end t)))
         (comment-id (gnus-reviews-track-individual-comment
                      comment-text status-symbol comment-order nil start)))
    (message "Tracked comment %s as %s: %s"
             comment-id status
             (substring comment-text 0 (min 50 (length comment-text))))))

;;;###autoload
(defun gnus-reviews-mark-comment-addressed ()
  "Mark a comment as addressed, considering current patch series context."
  (interactive)
  (let* ((series-comments (gnus-reviews-list-pending-comments-for-series))
         (pending-comments (if series-comments
                               series-comments
                             ;; Fall back to article-specific comments
                             (let ((article-comments (gnus-reviews-get-comments-for-article
                                                      (gnus-reviews--current-article-id))))
                               (cl-remove-if-not
                                (lambda (comment) (eq (nth 1 comment) 'pending))
                                article-comments)))))
    (if pending-comments
        (let* ((comment-choices (mapcar (lambda (comment)
                                          (let ((content (nth 2 (cdr comment))))
                                            (cons (format "%s: %s"
                                                          (car comment)
                                                          (if content
                                                              (substring content 0 (min 50 (length content)))
                                                            "No content"))
                                                  (car comment))))
                                        pending-comments))
               (choice (completing-read "Mark comment as addressed: " comment-choices))
               (comment-id (cdr (assoc choice comment-choices))))
          (gnus-reviews-update-comment-status comment-id 'addressed)
          (message "Marked comment %s as addressed" comment-id))
      (message "No pending comments found for this patch series"))))

;;;###autoload
(defun gnus-reviews-show-series-comments ()
  "Show all comments for the current patch series."
  (interactive)
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (if series-comments
        (with-output-to-temp-buffer "*Gnus Reviews: Series Comments*"
          (princ (format "Comments for patch series: %s\n"
                         (or (plist-get series-info :subject) "Unknown")))
          (princ "========================================\n\n")
          (dolist (comment series-comments)
            (let ((status (nth 1 (cdr comment)))
                  (content (nth 2 (cdr comment)))
                  (context (nth 5 (cdr comment)))
                  (timestamp (nth 4 (cdr comment))))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 200 (length content)))
                               "No content"))))))
      (message "No comments found for current patch series"))))

;;;###autoload
(defun gnus-reviews-show-article-comments ()
  "Show all individual comments for the current article."
  (interactive)
  (let* ((article-id (gnus-reviews--current-article-id))
         (comments (gnus-reviews-get-comments-for-article article-id)))
    (if comments
        (with-output-to-temp-buffer "*Gnus Reviews: Article Comments*"
          (princ (format "Individual comments for article: %s\n" article-id))
          (princ "==========================================\n\n")
          (dolist (comment comments)
            (let ((status (nth 1 comment))
                  (content (nth 2 comment))
                  (context (nth 5 comment))
                  (timestamp (nth 4 comment)))
              (princ (format "ID: %s\nStatus: %s\nTime: %s\n"
                             (car comment) status
                             (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
              (when context
                (princ (format "Context: %s\n" context)))
              (princ (format "Comment: %s\n\n"
                             (if content
                                 (substring content 0 (min 300 (length content)))
                               "No content"))))))
      (message "No individual comments found for current article"))))

;;;###autoload
(defun gnus-reviews-prune-old-reviews ()
  "Remove old completed/dismissed reviews older than specified days.
Uses `gnus-reviews-auto-expire-days' as the cutoff age.
Keeps all pending comments regardless of age."
  (interactive)
  (let ((cutoff-time (time-subtract (current-time)
                                    (days-to-time gnus-reviews-auto-expire-days)))
        (removed-count 0))
    ;; Remove only old completed/dismissed comments, keep pending ones
    (setq gnus-reviews-comment-database
          (mapcar (lambda (article-entry)
                    (cons (car article-entry)
                          (cl-remove-if (lambda (comment)
                                          (let ((comment-time (nth 4 comment))
                                                (status (nth 1 comment)))
                                            (when (and comment-time
                                                       (time-less-p comment-time cutoff-time)
                                                       (memq status '(addressed dismissed)))
                                              (cl-incf removed-count)
                                              t)))
                                        (cdr article-entry))))
                  gnus-reviews-comment-database))
    ;; Remove empty article entries
    (setq gnus-reviews-comment-database
          (cl-remove-if (lambda (entry) (null (cdr entry)))
                        gnus-reviews-comment-database))
    ;; Save changes
    (gnus-reviews--save-data)
    (message "Removed %d old completed comments (kept %d pending ones)"
             removed-count
             (length (gnus-reviews-list-pending-comments)))))

;; Provide the package
(provide 'gnus-reviews)

;;; gnus-reviews.el ends here
