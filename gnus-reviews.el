;;; gnus-reviews.el --- Email-based code review management for Gnus  -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Red Hat, Inc.

;; Author: Claude Code <noreply@anthropic.com>
;; Version: 1.0.0
;; Package-Requires: ((emacs "26.1") (gnus "5.13"))
;; Keywords: mail, gnus, code-review, development
;; URL: https://github.com/mz-pdm/gnus-reviews
;; Homepage: https://github.com/mz-pdm/gnus-reviews

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package provides tools for managing email-based code reviews in Gnus.
;; It helps organize review messages into appropriate groups, track individual
;; comments and their status, and manage the review lifecycle.
;;
;; Main features:
;; - Automatic classification of patch emails vs. review comments
;; - Organization of messages into purpose-specific Gnus groups
;; - Comment tracking and status management
;; - Review pruning and cleanup
;; - Score boosting for review-relevant articles
;;
;; While designed with libcamera development in mind, this package is generic
;; and can be used with any email-based code review workflow.

;;; Code:

(require 'gnus)
(require 'gnus-sum)
(require 'gnus-art)
(require 'gnus-score)
(require 'gnus-group)
(require 'message)
(require 'cl-lib)

;;; Constants and Variables

(defgroup gnus-reviews nil
  "Email-based code review management for Gnus."
  :group 'gnus
  :prefix "gnus-reviews-")

(defcustom gnus-reviews-base-group "nnml:reviews"
  "Base group name for review-related messages."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-own-patches-group (concat gnus-reviews-base-group ".patches")
  "Group for reviews of your own patches."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-to-review-group (concat gnus-reviews-base-group ".reviews")
  "Group for patches you intend to review."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-watching-group (concat gnus-reviews-base-group ".watching")
  "Group for patches you want to watch without reviewing."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-finished-group (concat gnus-reviews-base-group ".finished")
  "Group for completed reviews."
  :type 'string
  :group 'gnus-reviews)

(defcustom gnus-reviews-score-increase 1000
  "Score increase for review-relevant articles."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-expire-days 30
  "Number of days after which completed reviews are auto-expired."
  :type 'integer
  :group 'gnus-reviews)

(defcustom gnus-reviews-data-file "~/.emacs.d/gnus-reviews-data.el"
  "File to store persistent review data."
  :type 'file
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-email nil
  "Email address to use for identifying own patches.
If nil, uses `user-mail-address'."
  :type '(choice (const :tag "Use user-mail-address" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-user-name nil
  "Full name to use for identifying own patches.
If nil, uses `user-full-name'."
  :type '(choice (const :tag "Use user-full-name" nil)
                 string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-auto-create-groups t
  "Whether to automatically create review groups if they don't exist."
  :type 'boolean
  :group 'gnus-reviews)

(defvar gnus-reviews-comment-database nil
  "Database of tracked review comments.
Format: ((message-id . ((comment-id . comment-plist) ...)) ...)
where comment-plist is
(:status status :content content :thread-id thread-id :timestamp timestamp :context context)")

;;; Data Persistence Functions

(defun gnus-reviews--save-data ()
  "Save review data to persistent storage."
  (with-temp-file gnus-reviews-data-file
    (insert ";; Gnus Reviews Data File\n")
    (insert ";; This file is automatically generated. Do not edit manually.\n\n")
    (insert "(setq gnus-reviews-comment-database (quote\n")
    (prin1 gnus-reviews-comment-database (current-buffer))
    (insert "))\n")))

(defun gnus-reviews--load-data ()
  "Load review data from persistent storage."
  (when (and gnus-reviews-data-file (file-exists-p gnus-reviews-data-file))
    (load gnus-reviews-data-file t t)))

(defun gnus-reviews--comments ()
  (unless gnus-reviews-comment-database
    (gnus-reviews--load-data))
  gnus-reviews-comment-database)

(defun gnus-reviews--store-comments (comments)
  (setq gnus-reviews-comment-database comments)
  (gnus-reviews--save-data))

;;; Group Management Functions

(defun gnus-reviews--group-exists-p (group)
  "Check if GROUP exists in Gnus."
  (and group (gnus-group-entry group)))

(defun gnus-reviews--create-group (group)
  "Create GROUP if it doesn't exist and auto-creation is enabled."
  (when (and gnus-reviews-auto-create-groups
             group
             (not (gnus-reviews--group-exists-p group)))
    (gnus-group-make-group (gnus-group-short-name group) "nnml" "")
    (message "Created review group: %s" group)))

(defun gnus-reviews--ensure-groups ()
  "Ensure all review groups exist, creating them if necessary."
  (unless (and (boundp 'gnus-group-buffer)
               gnus-group-buffer
               (get-buffer gnus-group-buffer))
    (error "Gnus group buffer is not available - ensure Gnus is running"))
  (with-current-buffer gnus-group-buffer
    (mapc #'gnus-reviews--create-group
          (list gnus-reviews-base-group
                gnus-reviews-own-patches-group
                gnus-reviews-to-review-group
                gnus-reviews-watching-group
                gnus-reviews-finished-group))))

;;; Validation and Initialization Functions

(defun gnus-reviews--get-user-email ()
  "Get the user's email address for patch identification."
  (or gnus-reviews-user-email user-mail-address))

(defun gnus-reviews--get-user-name ()
  "Get the user's full name for patch identification."
  (or gnus-reviews-user-name user-full-name))

;;; Utility Functions

(defun gnus-reviews--article-header (func field)
  (cond
   ;; Try to get from article buffer context first (most reliable)
   ((and (boundp 'gnus-current-headers) gnus-current-headers)
    (funcall func gnus-current-headers))
   ;; Try getting from article buffer if we're in one
   ((gnus-buffer-live-p gnus-article-buffer)
    (with-current-buffer gnus-article-buffer
      (when (and (boundp 'gnus-current-headers) gnus-current-headers)
        (funcall func gnus-current-headers))))
   ;; Fall back to summary buffer approach
   ((and (gnus-summary-article-number)
         (gnus-summary-article-header))
    (funcall func (gnus-summary-article-header)))
   ;; Last resort: try to extract from raw article headers
   (t
    (gnus-with-article-headers
      (gnus-fetch-field field)))))

(defun gnus-reviews--current-article-id ()
  "Return the Message-ID of the current article."
  (gnus-reviews--article-header #'mail-header-id "Message-ID"))

(defun gnus-reviews--current-thread-id ()
  "Get the thread ID of the current article.
Uses References headers to determine thread membership,
falls back to Message-ID if no References header is available."
  (or (when-let ((refs (gnus-reviews--article-header #'mail-header-references "References")))
        (unless (equal refs "")
          (car (split-string refs " "))))
      (gnus-reviews--current-article-id)))

;;; Message Classification

(defcustom gnus-reviews-patch-patterns
  '("^\\[PATCH[^]]*\\]" "^\\[RFC[^]]*\\]" "^diff --git" "^---.*\\+\\+\\+" "^Index: ")
  "Patterns that indicate a message contains a patch."
  :type '(repeat string)
  :group 'gnus-reviews)

(defcustom gnus-reviews-review-patterns
  '("^Re:.*\\[PATCH" "^Re:.*\\[RFC" "Reviewed-by:" "Acked-by:" "Tested-by:"
    "^On .* wrote:" "> .*" "inline comment")
  "Patterns that indicate a message is a review comment."
  :type '(repeat string)
  :group 'gnus-reviews)

(defun gnus-reviews--match-patterns (content patterns)
  "Check if CONTENT matches any of the PATTERNS."
  (cl-some (lambda (pattern)
             (string-match-p pattern content))
           patterns))

(defun gnus-reviews-is-patch-email-p ()
  "Return non-nil if current article is a patch email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string)))
      (or (and subject (gnus-reviews--match-patterns subject gnus-reviews-patch-patterns))
          (gnus-reviews--match-patterns content gnus-reviews-patch-patterns)))))

(defun gnus-reviews-is-own-patch-email-p ()
  "Return non-nil if current article is a patch by the user."
  (gnus-with-article-buffer
    (let ((from (gnus-fetch-field "From"))
          (user-email (gnus-reviews--get-user-email))
          (user-name (gnus-reviews--get-user-name)))
      (and from
           (or (and user-email (string-match (regexp-quote user-email) from))
               (and user-name (string-match (regexp-quote user-name) from)))
           (gnus-reviews-is-patch-email-p)))))

(defun gnus-reviews-is-review-email-p ()
  "Return non-nil if current article is a review email."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject"))
          (content (buffer-string))
          (in-reply-to (gnus-fetch-field "In-Reply-To")))
      (and subject
           (not (gnus-reviews-is-patch-email-p))
           (or in-reply-to (string-match "^Re:" subject))
           (or (gnus-reviews--match-patterns subject gnus-reviews-review-patterns)
               (gnus-reviews--match-patterns content gnus-reviews-review-patterns))))))

(defun gnus-reviews-extract-patch-info ()
  "Extract patch information from the current article.
Returns a plist with :series-num, :series-total, :version, :subject."
  (gnus-with-article-buffer
    (let ((subject (gnus-fetch-field "Subject")))
      (when subject
        (cond
         ;; PATCH series with version and series numbers
         ((string-match (rx "["
                            "PATCH"
                            (optional (seq (+ whitespace) "v" (group (+ digit))))
                            (+ whitespace)
                            (group (+ digit))
                            "/"
                            (group (+ digit))
                            "]"
                            (* whitespace)
                            (group (* anything)))
                        subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))))
         ;; RFC series with version and series numbers
         ((string-match (rx "["
                            "RFC"
                            (optional (seq (+ whitespace) "PATCH"))
                            (optional (seq (+ whitespace) "v" (group (+ digit))))
                            (+ whitespace)
                            (group (+ digit))
                            "/"
                            (group (+ digit))
                            "]"
                            (* whitespace)
                            (group (* anything)))
                        subject)
          (list :version (match-string 1 subject)
                :series-num (string-to-number (match-string 2 subject))
                :series-total (string-to-number (match-string 3 subject))
                :subject (string-trim (match-string 4 subject))
                :rfc t))
         ;; Single PATCH with version
         ((string-match (rx "["
                            "PATCH"
                            (optional (seq (+ whitespace) "v" (group (+ digit))))
                            "]"
                            (* whitespace)
                            (group (* anything)))
                        subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))))
         ;; Single RFC with version
         ((string-match (rx "["
                            "RFC"
                            (optional (seq (+ whitespace) "PATCH"))
                            (optional (seq (+ whitespace) "v" (group (+ digit))))
                            "]"
                            (* whitespace)
                            (group (* anything)))
                        subject)
          (list :version (match-string 1 subject)
                :series-num 1
                :series-total 1
                :subject (string-trim (match-string 2 subject))
                :rfc t)))))))

;;; Comment Tracking System

(defun gnus-reviews--generate-comment-id (article-id comment-order)
  "Generate a deterministic unique comment ID.
ARTICLE-ID identifies the article, COMMENT-ORDER is the sequential order
of this comment within the article (1-based)."
  (format "%s#%d" article-id comment-order))

(defun gnus-reviews--parse-individual-comments ()
  "Parse individual review comments from current article.
Returns a list of (content start-pos end-pos context) for each comment."
  (gnus-with-article-buffer
    (let ((content (buffer-string))
          (comments '())
          (body-start 0))
      ;; Skip headers
      (when (string-match "\n\n" content)
        (setq body-start (match-end 0)))

      (with-temp-buffer
        (insert (substring content body-start))
        (goto-char (point-min))

        (let ((current-context nil)
              (comment-lines '())
              (comment-start-pos nil))

          (while (not (eobp))
            (cond
             ;; Found quoted line - save any accumulated comment block first
             ((looking-at "^> \\(.+\\)$")
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))
              ;; Update context for future comments
              (setq current-context (match-string-no-properties 1)))

             ;; Found non-quoted, non-empty line
             ((looking-at "^\\([^>\n].*\\)$")
              (let ((line-text (save-match-data (string-trim (match-string-no-properties 1)))))
                ;; Exclude signature lines, headers, email reply introductions, and greetings
                (when (and (> (length line-text) 0)
                           (string-match "\\w" line-text)
                           (not (or
                                 ;; Email reply introductions
                                 (string-match-p "^On " line-text)
                                 (string-match-p " wrote:[ \t]*$" line-text)
                                 (string-match-p " writes:[ \t]*$" line-text)
                                 ;; Signature lines
                                 (string-match-p "^--" line-text)
                                 (string-match-p "^___" line-text)
                                 ;; Headers
                                 (string-match-p "^\\(From\\|Subject\\|Date\\|To\\|Cc\\):" line-text)
                                 ;; Common greetings and closings (case insensitive)
                                 (string-match-p "^[ \t]*\\(hi\\|hello\\|hey\\|dear\\)\\($\\|[ \t,]\\)"
                                                 (downcase line-text))
                                 (string-match-p "^[ \t]*\\(regards\\|best\\|thanks\\|thank you\\|cheers\\|sincerely\\|yours\\)\\( regards\\| wishes\\)?[ \t,]*$"
                                                 (downcase line-text)))))
                  (when (null comment-start-pos)
                    (setq comment-start-pos (line-beginning-position)))
                  (push line-text comment-lines))))

             ;; Empty line or other - save accumulated comment block if any
             (t
              (when comment-lines
                (let ((comment-text (string-join (nreverse comment-lines) "\n")))
                  (when (and (> (length comment-text) 0)
                             (string-match "\\w" comment-text))
                    (push (list comment-text
                                (+ body-start comment-start-pos)
                                (+ body-start (line-end-position 0))
                                current-context)
                          comments)))
                (setq comment-lines nil
                      comment-start-pos nil))))

            (forward-line 1))

          ;; Handle any remaining comment block at end of buffer
          (when comment-lines
            (let ((comment-text (string-join (nreverse comment-lines) "\n")))
              (when (and (> (length comment-text) 0)
                         (string-match "\\w" comment-text))
                (push (list comment-text
                            (+ body-start comment-start-pos)
                            (+ body-start (point-max))
                            current-context)
                      comments))))))

      (nreverse comments))))

(defun gnus-reviews-track-individual-comment (comment-text status comment-order &optional context)
  "Track an individual review comment.
COMMENT-TEXT is the actual comment content.
STATUS should be one of: `pending', `addressed', `dismissed'.
COMMENT-ORDER is the sequential order of this comment within the article (1-based).
CONTEXT is optional code context the comment refers to."
  (let* ((article-id (gnus-reviews--current-article-id))
         (thread-id (gnus-reviews--current-thread-id))
         (comment-id (gnus-reviews--generate-comment-id article-id comment-order))
         (comment-data (list :status status
                             :content comment-text
                             :thread-id thread-id
                             :timestamp (current-time)
                             :context context)))
    (unless article-id
      (error "No article ID available - ensure there is a Gnus article buffer"))
    ;; Add to comment database
    (let ((article-comments (assoc article-id (gnus-reviews--comments))))
      (if article-comments
          (setcdr article-comments
                  (cons (cons comment-id comment-data) (cdr article-comments)))
        (gnus-reviews--store-comments (cons (cons article-id (list (cons comment-id comment-data)))
                                            (gnus-reviews--comments)))))
    comment-id))

(defun gnus-reviews-get-comments-for-article (article-id)
  "Get all tracked comments for ARTICLE-ID."
  (cdr (assoc article-id (gnus-reviews--comments))))

(defun gnus-reviews-update-comment-status (article-id comment-id new-status)
  "Update the status of COMMENT-ID in ARTICLE-ID to NEW-STATUS."
  (when-let ((comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                  (gnus-reviews-get-comments-for-article article-id))))
    (plist-put (cdr comment) :status new-status)
    (gnus-reviews--save-data)))

(defun gnus-reviews-update-comment-content (article-id comment-id new-content)
  "Update the content of COMMENT-ID in ARTICLE-ID to NEW-CONTENT."
  (when-let ((comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                  (gnus-reviews-get-comments-for-article article-id))))
    (plist-put (cdr comment) :content new-content)
    (gnus-reviews--save-data)))

(defun gnus-reviews--get-status-choices (comment-order)
  "Get available status choices for a comment based on its order.
COMMENT-ORDER is the sequential position of the comment (1-based).
Returns a list of status strings, including 'merge' only if comment-order > 1."
  (let ((base-choices '("pending" "addressed" "dismissed" "skip")))
    (if (> comment-order 1)
        (append '("merge") base-choices)
      base-choices)))

(defun gnus-reviews-list-pending-comments ()
  "List all pending comments across all articles."
  (let (pending)
    (dolist (article-entry (gnus-reviews--comments))
      (dolist (comment (cdr article-entry))
        (when (eq (plist-get (cdr comment) :status) 'pending)
          (push (list (car comment)           ; comment-id
                      (car article-entry)     ; article-id
                      (plist-get (cdr comment) :status)) ; status
                pending))))
    pending))

(defun gnus-reviews--get-current-patch-series ()
  "Get patch series information for the current context."
  (gnus-with-article-buffer
    (let* ((thread-id (gnus-reviews--current-thread-id))
           (patch-info (gnus-reviews-extract-patch-info)))
      (when patch-info
        (list :thread-id thread-id
              :subject (plist-get patch-info :subject)
              :series-total (plist-get patch-info :series-total)
              :version (plist-get patch-info :version))))))

(defun gnus-reviews-get-series-comments (series-info)
  "Get all comments related to a patch series."
  (when series-info
    (let* ((thread-id (plist-get series-info :thread-id))
           (series-comments '()))
      (dolist (article-entry (gnus-reviews--comments))
        (dolist (comment (cdr article-entry))
          (when (string= (plist-get (cdr comment) :thread-id) thread-id)
            (push comment series-comments))))
      series-comments)))

(defun gnus-reviews-list-pending-comments-for-series ()
  "List pending comments for the current patch series only."
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (cl-remove-if-not (lambda (comment) (eq (plist-get (cdr comment) :status) 'pending))
                      series-comments)))

;;; Core Functions

(defun gnus-reviews-classify-message ()
  "Classify the current message and return its type.
Returns one of: `own-patch', `review-comment', `patch', `other'."
  (cond
   ((and (gnus-reviews-is-patch-email-p) (gnus-reviews-is-own-patch-email-p))
    'own-patch)
   ((gnus-reviews-is-review-email-p)
    'review-comment)
   ((gnus-reviews-is-patch-email-p)
    'patch)
   (t 'other)))

;;; Public Interface

(defun gnus-reviews--collect-thread-articles ()
  "Collect all article numbers in the current thread including siblings.
Returns a list of article numbers in the complete thread."
  (let ((thread-articles '())
        (current-article (gnus-summary-article-number)))
    (when current-article
      (save-excursion
        ;; Move to the thread root to ensure we get the whole thread
        (gnus-summary-refer-thread)
        (gnus-summary-top-thread)
        ;; Collect all articles in the entire thread (including siblings)
        (let ((thread-root (gnus-summary-article-number))
              (visited (make-hash-table :test 'equal)))
          ;; Add the root article
          (push thread-root thread-articles)
          (puthash thread-root t visited)
          ;; Navigate through the entire thread structure
          (gnus-summary-goto-article thread-root)
          (let ((start-pos (point)))
            ;; Move to next thread to find the boundary
            (if (= (gnus-summary-next-thread 1) 0)
                (let ((end-pos (line-end-position 0)))
                  ;; Go back to start and collect all articles until next thread
                  (goto-char start-pos)
                  (while (< (point) end-pos)
                    (when-let ((article-num (gnus-summary-article-number)))
                      (unless (gethash article-num visited)
                        (push article-num thread-articles)
                        (puthash article-num t visited)))
                    (forward-line 1)))
              ;; If no next thread, go to end of buffer
              (goto-char start-pos)
              (while (not (eobp))
                (when-let ((article-num (gnus-summary-article-number)))
                  (unless (gethash article-num visited)
                    (push article-num thread-articles)
                    (puthash article-num t visited)))
                (forward-line 1)))))))
    (nreverse thread-articles)))

(defun gnus-reviews--copy-and-tick-articles (articles target-group)
  "Copy and tick ARTICLES to TARGET-GROUP.
Returns the number of articles successfully copied."
  (let ((copied-count 0))
    (when articles
      (dolist (article-num articles)
        (when (gnus-summary-goto-article article-num)
          ;; Tick the article before copying to preserve the tick status
          (gnus-summary-mark-article nil gnus-ticked-mark)
          (gnus-summary-copy-article nil target-group)
          (cl-incf copied-count))))
    copied-count))

;;; Interactive Comment Display

(defvar gnus-reviews-comment-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") #'gnus-reviews--comment-change-status)
    (define-key map (kbd "c") #'gnus-reviews--comment-change-status)
    (define-key map (kbd "s") #'gnus-reviews--comment-change-status)
    (define-key map (kbd "d") #'gnus-reviews--comment-delete)
    (define-key map (kbd "e") #'gnus-reviews--comment-edit)
    (define-key map (kbd "v") #'gnus-reviews--comment-view-full)
    (define-key map (kbd "y") #'gnus-reviews--comment-copy)
    (define-key map (kbd "a") #'gnus-reviews--comment-show-article)
    (define-key map (kbd "h") #'gnus-reviews--comment-help)
    (define-key map (kbd "?") #'gnus-reviews--comment-help)
    (define-key map [mouse-1] #'gnus-reviews--comment-change-status)
    (define-key map [mouse-3] #'gnus-reviews--comment-help)
    map)
  "Keymap for interactive comment actions.")

(defun gnus-reviews--get-comment-at-point ()
  "Get the comment ID and article ID at point."
  (let ((comment-id (get-text-property (point) 'gnus-reviews-comment-id))
        (article-id (get-text-property (point) 'gnus-reviews-article-id)))
    (when (and comment-id article-id)
      (list article-id comment-id))))

(defun gnus-reviews--comment-change-status ()
  "Change the status of the comment at point."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info))
           (comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                (gnus-reviews-get-comments-for-article article-id)))
           (current-status (when comment (plist-get (cdr comment) :status)))
           (new-status (completing-read
                        (format "Change status from %s to: " current-status)
                        '("pending" "addressed" "dismissed") nil t)))
      (when comment
        (gnus-reviews-update-comment-status article-id comment-id (intern new-status))
        (message "Changed comment %s status to %s" comment-id new-status)
        ;; Refresh the display buffer
        (gnus-reviews--refresh-comment-buffer)))))

(defun gnus-reviews--comment-delete ()
  "Delete the comment at point."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info)))
      (when (yes-or-no-p (format "Delete comment %s? " comment-id))
        ;; Remove comment from database
        (let* ((article-comments (assoc article-id (gnus-reviews--comments)))
               (updated-comments (cl-remove-if
                                  (lambda (c) (string= (car c) comment-id))
                                  (cdr article-comments))))
          (setcdr article-comments updated-comments)
          (gnus-reviews--save-data)
          (message "Deleted comment %s" comment-id)
          ;; Refresh the display buffer
          (gnus-reviews--refresh-comment-buffer))))))

(defun gnus-reviews--comment-edit ()
  "Edit the content of the comment at point."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info))
           (comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                (gnus-reviews-get-comments-for-article article-id)))
           (current-content (when comment (plist-get (cdr comment) :content))))
      (when comment
        (let ((new-content (read-string "Edit comment: " current-content)))
          (gnus-reviews-update-comment-content article-id comment-id new-content)
          (message "Updated comment %s" comment-id)
          ;; Refresh the display buffer
          (gnus-reviews--refresh-comment-buffer))))))

(defun gnus-reviews--comment-view-full ()
  "View the full content of the comment at point."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info))
           (comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                (gnus-reviews-get-comments-for-article article-id)))
           (content (when comment (plist-get (cdr comment) :content))))
      (when content
        (with-output-to-temp-buffer "*Gnus Reviews: Full Comment*"
          (princ (format "Comment ID: %s\n" comment-id))
          (princ (format "Article ID: %s\n\n" article-id))
          (princ content))))))

(defun gnus-reviews--comment-copy ()
  "Copy the content of the comment at point to the kill ring."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info))
           (comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                (gnus-reviews-get-comments-for-article article-id)))
           (content (when comment (plist-get (cdr comment) :content))))
      (when content
        (kill-new content)
        (message "Copied comment content to kill ring")))))

(defun gnus-reviews--comment-show-article ()
  "Show the article of the current comment and jump to the comment within it."
  (interactive)
  (when-let ((comment-info (gnus-reviews--get-comment-at-point)))
    (let* ((article-id (car comment-info))
           (comment-id (cadr comment-info))
           (comment (cl-find-if (lambda (c) (string= (car c) comment-id))
                                (gnus-reviews-get-comments-for-article article-id)))
           (comment-content (when comment (plist-get (cdr comment) :content))))
      (if (not comment-content)
          (message "Could not find comment content for %s" comment-id)
        ;; Use gnus-summary-refer-article to jump to the article by Message-ID
        (condition-case err
            (progn
              ;; Ensure we're in a summary buffer
              (unless (and (boundp 'gnus-summary-buffer)
                           gnus-summary-buffer
                           (buffer-live-p gnus-summary-buffer))
                (error "No Gnus summary buffer available"))
              ;; Switch to summary buffer and refer to the article
              (switch-to-buffer gnus-summary-buffer)
              (gnus-summary-refer-article article-id)
              ;; Switch to article buffer and search for comment
              (when (and (boundp 'gnus-article-buffer)
                         gnus-article-buffer
                         (buffer-live-p gnus-article-buffer))
                (pop-to-buffer gnus-article-buffer)
                ;; Search for the comment content in the article
                (goto-char (point-min))
                (if (search-forward comment-content nil t)
                    (progn
                      (goto-char (match-beginning 0))
                      (message "Jumped to comment in article: %s" comment-id))
                  (message "Found article but could not locate comment text"))))
          (error
           (message "Could not find or refer to article %s: %s" article-id (error-message-string err))))))))

(defun gnus-reviews--comment-help ()
  "Show help for comment interactions."
  (interactive)
  (with-output-to-temp-buffer "*Gnus Reviews: Comment Help*"
    (princ "Comment Interaction Keys:\n")
    (princ "========================\n\n")
    (princ "RET, c, s  - Change comment status\n")
    (princ "d          - Delete comment\n")
    (princ "e          - Edit comment content\n")
    (princ "v          - View full comment\n")
    (princ "y          - Copy comment to kill ring\n")
    (princ "a          - Show article and jump to comment\n")
    (princ "h, ?       - Show this help\n\n")
    (princ "Mouse:\n")
    (princ "Left click  - Change comment status\n")
    (princ "Right click - Show help\n")))

(defun gnus-reviews--boost-thread-score (thread-root-article)
  "Boost score for the entire thread starting from THREAD-ROOT-ARTICLE."
  (save-excursion
    (gnus-summary-goto-article thread-root-article)
    (gnus-reviews-increase-score)))

(defun gnus-reviews--display-comment (comment-id comment-data &optional content-limit)
  "Display a single comment with formatted output.
COMMENT-ID is the comment identifier.
COMMENT-DATA is the comment property list.
CONTENT-LIMIT is the maximum number of characters to show from content (default 200)."
  (let ((status (plist-get comment-data :status))
        (content (plist-get comment-data :content))
        (context (plist-get comment-data :context))
        (timestamp (plist-get comment-data :timestamp))
        (limit (or content-limit 200))
        (start-pos (point))
        (article-id (car (split-string comment-id "#"))))
    ;; Display ID and timestamp
    (insert (format "ID: %s\nTime: %s\n" comment-id
                    (if timestamp (format-time-string "%Y-%m-%d %H:%M" timestamp) "Unknown")))
    ;; Display status with highlighting
    (insert "Status: ")
    (let ((status-face (pcase status
                        ('pending 'warning)
                        ('addressed 'success)
                        ('dismissed 'shadow)
                        (_ 'default))))
      (insert (propertize (format "%s" status) 'face status-face)))
    (insert "\n")
    ;; Display context if available
    (when context
      (insert (format "Context: %s\n" (propertize context 'face 'italic))))
    ;; Display comment content with highlighting
    (insert "Comment: ")
    (let ((comment-text (if content
                            (substring content 0 (min limit (length content)))
                          "No content")))
      (insert (propertize comment-text 'face 'highlight)))

    ;; Add interactive properties to the entire comment block
    (let ((end-pos (point)))
      (insert "\n\n")
      (add-text-properties start-pos end-pos
                           (list 'gnus-reviews-comment-id comment-id
                                 'gnus-reviews-article-id article-id
                                 'keymap gnus-reviews-comment-keymap
                                 'mouse-face 'highlight
                                 'help-echo "RET/c/s: change status, d: delete, e: edit, v: view full, y: copy, h: help")))))

(defun gnus-reviews--refresh-comment-buffer ()
  "Refresh the current comment display buffer."
  (let ((buffer-name (buffer-name)))
    (cond
     ;; Refresh series comments buffer
     ((string= buffer-name "*Gnus Reviews: Series Comments*")
      (let* ((series-info (gnus-reviews--get-current-patch-series))
             (series-comments (gnus-reviews-get-series-comments series-info)))
        (when series-comments
          (gnus-reviews--regenerate-comment-buffer
           buffer-name
           (format "Comments for patch series: %s"
                   (or (plist-get series-info :subject) "Unknown"))
           series-comments 200))))

     ;; Refresh pending series comments buffer
     ((string= buffer-name "*Gnus Reviews: Pending Series Comments*")
      (let* ((series-info (gnus-reviews--get-current-patch-series))
             (pending-comments (gnus-reviews-list-pending-comments-for-series)))
        (when pending-comments
          (gnus-reviews--regenerate-comment-buffer
           buffer-name
           (format "Pending comments for patch series: %s"
                   (or (plist-get series-info :subject) "Unknown"))
           pending-comments 200))))

     ;; Refresh article comments buffer
     ((string= buffer-name "*Gnus Reviews: Article Comments*")
      (let* ((article-id (gnus-reviews--current-article-id))
             (comments (gnus-reviews-get-comments-for-article article-id)))
        (when comments
          (gnus-reviews--regenerate-comment-buffer
           buffer-name
           (format "Individual comments for article: %s" article-id)
           comments 300)))))))

(defun gnus-reviews--regenerate-comment-buffer (buffer-name title comments content-limit)
  "Regenerate the content of an existing comment buffer.
BUFFER-NAME is the name of the buffer to regenerate.
TITLE is the header text to display.
COMMENTS is the list of comments to display.
CONTENT-LIMIT is maximum characters to show from each comment."
  (when-let ((buffer (get-buffer buffer-name)))
    (with-current-buffer buffer
      (let ((inhibit-read-only t)
            (current-pos (point)))
        (erase-buffer)
        (insert (format "%s\n" title))
        (insert (make-string (length title) ?=))
        (insert "\n\n")
        (dolist (comment comments)
          (gnus-reviews--display-comment
           (car comment)
           (cdr comment)
           content-limit))
        ;; Try to restore cursor position, or go to the beginning
        (goto-char (min current-pos (point-max)))))))

(defun gnus-reviews--display-comment-list (buffer-name title comments &optional content-limit refresh-function)
  "Display a list of comments in a temporary buffer.
BUFFER-NAME is the name of the buffer to create.
TITLE is the header text to display.
COMMENTS is the list of comments to display.
CONTENT-LIMIT is optional maximum characters to show from each comment.
REFRESH-FUNCTION is optional function to refresh the buffer content."
  (let ((buffer (get-buffer-create buffer-name)))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert (format "%s\n" title))
        (insert (make-string (length title) ?=))
        (insert "\n\n")
        (dolist (comment comments)
          (gnus-reviews--display-comment
           (car comment)
           (cdr comment)
           content-limit))
        (goto-char (point-min))
        (help-mode)
        ;; Set up proper revert-buffer-function to handle M-x revert-buffer
        (setq-local revert-buffer-function
                    (lambda (&optional ignore-auto noconfirm)
                      (gnus-reviews--refresh-comment-buffer)))
        ;; Set up buffer-local refresh function (legacy, may remove later)
        (when refresh-function
          (setq-local gnus-reviews-buffer-refresh-function refresh-function))))
    (pop-to-buffer buffer)))

(defun gnus-reviews--process-thread-action (target-group message-format)
  "Perform a standard action on the current thread.
This involves ensuring groups exist, collecting thread articles,
copying them to TARGET-GROUP, boosting the thread score,
and displaying a formatted message."
  (interactive)
  (gnus-reviews--ensure-groups)
  (let* ((current-article (gnus-summary-article-number))
         (thread-articles (gnus-reviews--collect-thread-articles))
         (thread-root (car thread-articles)))
    (when thread-articles
      (let ((copied-count (gnus-reviews--copy-and-tick-articles thread-articles target-group)))
        ;; Boost score for thread and return to original article
        (when thread-root
          (gnus-reviews--boost-thread-score thread-root))
        (when current-article
          (gnus-summary-goto-article current-article))
        (message message-format copied-count target-group)))))


;;;###autoload
(defun gnus-reviews-add-reviewed-by-tag ()
  "Insert a Reviewed-by tag with user's name and email at point."
  (interactive)
  (let ((name (gnus-reviews--get-user-name))
        (email (gnus-reviews--get-user-email)))
    (if (and name email)
        (insert (format "Reviewed-by: %s <%s>\n" name email))
      (message "User name or email not configured. See `gnus-reviews-user-name' and `gnus-reviews-user-email'."))))

;;;###autoload
(defun gnus-reviews-copy-to-group (&optional group)
  "Copy current article to GROUP.
When called interactively, automatically suggests an appropriate group
based on message classification but always asks for confirmation."
  (interactive
   (let* ((type (gnus-reviews-classify-message))
          (default-group (pcase type
                          ('own-patch gnus-reviews-own-patches-group)
                          ('review-comment gnus-reviews-to-review-group)
                          ('patch gnus-reviews-to-review-group)
                          (_ gnus-reviews-to-review-group)))
          (all-groups (list gnus-reviews-own-patches-group
                            gnus-reviews-to-review-group
                            gnus-reviews-watching-group
                            gnus-reviews-finished-group)))
     (list (completing-read
            (format "Copy to group (default %s): " default-group)
            all-groups nil t nil nil default-group))))
  (gnus-reviews--ensure-groups)
  (gnus-summary-copy-article nil group)
  (message "Copied article to %s" group))

;;;###autoload
(defun gnus-reviews-watch-thread ()
  "Watch the current thread by copying all thread articles to watching group.
Also increases the score for the thread to boost visibility."
  (interactive)
  (gnus-reviews--process-thread-action
   gnus-reviews-watching-group
   "Watched thread: copied %d articles to %s"))

(defun gnus-reviews--process-patch-review-helper (target-group)
  "Helper function to process a patch review and copy to TARGET-GROUP.
Extracts and tracks individual comments, ticks the article if there are
pending comments, and copies it to the specified target group for follow-up."
  (unless (gnus-reviews-is-review-email-p)
    (error "Current article is not a review email"))
  (gnus-reviews--ensure-groups)
  ;; Extract and track comments from the review
  (gnus-reviews-extract-and-track-comments)
  ;; Increase score for the subthread to boost visibility
  (gnus-reviews-increase-score)
  ;; Check for pending comments and tick only if found
  (let* ((article-id (gnus-reviews--current-article-id))
         (tracked-comments (gnus-reviews-get-comments-for-article article-id))
         (pending-count (cl-count-if (lambda (comment)
                                      (eq (plist-get (cdr comment) :status) 'pending))
                                    tracked-comments))
         (total-count (length tracked-comments)))
    ;; Tick the article only if there are pending comments
    (when (> pending-count 0)
      (gnus-summary-mark-article nil gnus-ticked-mark))
    ;; Copy to target group
    (gnus-summary-copy-article nil target-group)
    ;; Show feedback about what was processed
    (cond
     ((> pending-count 0)
      (message "Processed patch review: %d pending comments (of %d total), ticked and copied to %s"
               pending-count total-count target-group))
     ((> total-count 0)
      (message "Processed patch review: %d comments tracked (none pending), copied to %s"
               total-count target-group))
     (t
      (message "Processed patch review: no comments found, copied to %s"
               target-group)))))

;;;###autoload
(defun gnus-reviews-process-my-patch-review ()
  "Process a review of your own patch.
Extracts and tracks individual comments, ticks the article if there are
pending comments, and copies it to the own patches group for follow-up."
  (interactive)
  (gnus-reviews--process-patch-review-helper gnus-reviews-own-patches-group))

;;;###autoload
(defun gnus-reviews-process-others-patch-review ()
  "Process a review of someone else's patch.
Extracts and tracks individual comments, ticks the article if there are
pending comments, and copies it to the reviews group for follow-up."
  (interactive)
  (gnus-reviews--process-patch-review-helper gnus-reviews-to-review-group))

;;;###autoload
(defun gnus-reviews-copy-my-patch-series ()
  "Copy the entire current patch series to own patches group.
Ticks all articles in the series, copies them to own patches group,
and increases score for better visibility. Use this when you want to
track your own patch series without processing review comments."
  (interactive)
  (gnus-reviews--process-thread-action
   gnus-reviews-own-patches-group
   "Copied patch series: %d articles ticked and copied to %s"))

;;;###autoload
(defun gnus-reviews-queue-series-for-review ()
  "Queue the entire current patch series for review.
Ticks all articles in the series, copies them to review group,
and increases score for better visibility. Use this when you want to
review someone else's patch series."
  (interactive)
  (gnus-reviews--process-thread-action
   gnus-reviews-to-review-group
   "Queued patch series for review: %d articles ticked and copied to %s"))

;;;###autoload
(defun gnus-reviews-increase-score ()
  "Increase score for the current review-related article subthread and subject.
Temporarily boosts the score of all articles in the subthread starting from
the current article and all articles with the same core subject (prefixes stripped)."
  (interactive)
  (when (or (gnus-reviews-is-patch-email-p)
            (gnus-reviews-is-review-email-p))
    (let ((article-id (gnus-reviews--current-article-id))
          (subject (gnus-with-article-buffer (gnus-fetch-field "Subject")))
          (score gnus-reviews-score-increase)
          (parts '()))
      ;; Score the subthread starting with current article
      (when article-id
        (gnus-summary-score-entry "thread" article-id 's score (current-time-string))
        (push "subthread" parts))
      ;; Score by cleaned subject (strip common prefixes)
      (when subject
        (let ((clean-subject (replace-regexp-in-string
                              "^\\(\\(Re: \\|Fwd: \\)*\\[\\(PATCH\\|RFC\\)[^]]*\\]\\s-*\\|\\(Re: \\|Fwd: \\)+\\)"
                              "" subject)))
          (when (> (length clean-subject) 0)
            (gnus-summary-score-entry "subject" clean-subject 's score (current-time-string))
            (push (format "subject '%s'" clean-subject) parts))))
      ;; Refresh the summary and show single message
      (gnus-summary-rescore)
      (when parts
        (message "Boosted %s score by %d" (string-join (nreverse parts) " and ") score)))))

;;;###autoload
(defun gnus-reviews-extract-and-track-comments ()
  "Extract individual comments from current article and assign status to each."
  (interactive)
  (when (gnus-reviews-is-review-email-p)
    (let* ((comments (gnus-reviews--parse-individual-comments))
           (tracked-count 0)
           (article-id (gnus-reviews--current-article-id))
           (existing-comments (gnus-reviews-get-comments-for-article article-id)))
      (if comments
          (progn
            (message "Found %d individual comments to process..." (length comments))
            (let ((comment-order 1))
              (dolist (comment comments)
                (let* ((text (nth 0 comment))
                       (context (nth 3 comment))
                       (display-text (if context
                                         (format "Context: %s\nComment: %s"
                                                 context
                                                 (substring text 0 (min 100 (length text))))
                                       (substring text 0 (min 100 (length text)))))
                       ;; Check if this comment already exists in the database
                       (existing-comment (cl-find-if
                                          (lambda (c) (string= (plist-get (cdr c) :content) text))
                                          existing-comments))
                       (existing-status (when existing-comment
                                          (plist-get (cdr existing-comment) :status)))
                       (default-status (when existing-status
                                         (symbol-name existing-status)))
                       ;; Get dynamic status choices based on comment order
                       (status-choices (gnus-reviews--get-status-choices comment-order))
                       (prompt-text (if existing-status
                                        (format "Status for comment [EXISTING: %s]: %s\n> "
                                                existing-status display-text)
                                      (format "Status for comment: %s\n> " display-text)))
                       (status (completing-read prompt-text status-choices nil t nil nil default-status)))
                  (cond
                   ((string= status "skip")
                    ;; Skip this comment entirely
                    nil)
                   ((string= status "merge")
                    ;; Merge with preceding comment
                    (if (> comment-order 1)
                        (let* ((preceding-comment-id (gnus-reviews--generate-comment-id article-id (1- comment-order)))
                               (preceding-comment (cl-find-if
                                                   (lambda (c) (string= (car c) preceding-comment-id))
                                                   existing-comments)))
                          (if preceding-comment
                              (let* ((preceding-content (plist-get (cdr preceding-comment) :content))
                                     (merged-content (concat preceding-content "\n\n" text)))
                                (gnus-reviews-update-comment-content article-id preceding-comment-id merged-content)
                                (message "Merged comment with preceding comment %s" preceding-comment-id)
                                (cl-incf tracked-count))
                            (message "No preceding comment found to merge with, tracking as new comment")
                            (gnus-reviews-track-individual-comment text 'pending comment-order context)
                            (cl-incf tracked-count)))
                      (message "No preceding comment to merge with (this is the first comment), tracking as new comment")
                      (gnus-reviews-track-individual-comment text 'pending comment-order context)
                      (cl-incf tracked-count)))
                   (existing-comment
                    ;; Update existing comment status if it changed
                    (let ((new-status (intern status)))
                      (unless (eq existing-status new-status)
                        (gnus-reviews-update-comment-status article-id (car existing-comment) new-status)
                        (cl-incf tracked-count))))
                   (t
                    ;; Track new comment with specified status
                    (gnus-reviews-track-individual-comment text (intern status) comment-order context)
                    (cl-incf tracked-count)))
                  (cl-incf comment-order))))
            (gnus-reviews-increase-score)
            (message "Tracked %d individual comments" tracked-count))
        (message "No individual comments found in this article")))))

;;;###autoload
(defun gnus-reviews-mark-region-as-comment (start end status)
  "Mark the selected region as an individual comment.
START and END define the region.
STATUS should be one of: pending, addressed, dismissed."
  (interactive (list (region-beginning)
                     (region-end)
                     (completing-read "Comment status: "
                                      '("pending" "addressed" "dismissed")
                                      nil t)))
  (let* ((status-symbol (intern status))
         (comment-text (buffer-substring-no-properties start end))
         (all-comments (gnus-reviews--parse-individual-comments))
         (comment-order (1+ (cl-position-if (lambda (comment)
                                              (>= start (nth 1 comment)))
                                            all-comments
                                            :from-end t)))
         (comment-id (gnus-reviews-track-individual-comment
                      comment-text status-symbol comment-order nil)))
    (message "Tracked comment %s as %s: %s"
             comment-id status
             (substring comment-text 0 (min 50 (length comment-text))))))

;;;###autoload
(defun gnus-reviews-mark-comment-addressed ()
  "Mark a comment as addressed, considering current patch series context."
  (interactive)
  (if-let ((pending-comments (gnus-reviews-list-pending-comments-for-series)))
      (let* ((comment-choices (mapcar (lambda (comment)
                                        (let ((content (plist-get (cdr comment) :content)))
                                          (cons (format "%s: %s"
                                                        (car comment)
                                                        (if content
                                                            (substring content 0 (min 50 (length content)))
                                                          "No content"))
                                                (car comment))))
                                      pending-comments))
             (choice (completing-read "Mark comment as addressed: " comment-choices))
             (comment-id (cdr (assoc choice comment-choices))))
        (gnus-reviews-update-comment-status
         (car (split-string comment-id "#")) comment-id 'addressed)
        (message "Marked comment %s as addressed" comment-id))
    (message "No pending comments found for this patch series")))

;;;###autoload
(defun gnus-reviews-change-comment-status ()
  "Change the status of a comment to an interactively selected value."
  (interactive)
  (if-let ((all-comments (gnus-reviews-get-series-comments
                          (gnus-reviews--get-current-patch-series))))
      (let* ((comment-choices (mapcar (lambda (comment)
                                        (let* ((comment-data (cdr comment))
                                               (content (plist-get comment-data :content))
                                               (current-status (plist-get comment-data :status)))
                                          (cons (format "%s [%s]: %s"
                                                        (car comment)
                                                        current-status
                                                        (if content
                                                            (substring content 0 (min 50 (length content)))
                                                          "No content"))
                                                (car comment))))
                                      all-comments))
             (choice (completing-read "Change status for comment: " comment-choices))
             (comment-id (cdr (assoc choice comment-choices)))
             (new-status (completing-read "New status: "
                                         '("pending" "addressed" "dismissed")
                                         nil t)))
        (gnus-reviews-update-comment-status
         (car (split-string comment-id "#")) comment-id (intern new-status))
        (message "Changed comment %s status to %s" comment-id new-status))
    (message "No comments found for current context")))

;;;###autoload
(defun gnus-reviews-show-series-comments ()
  "Show all comments for the current patch series."
  (interactive)
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (series-comments (gnus-reviews-get-series-comments series-info)))
    (if series-comments
        (gnus-reviews--display-comment-list
         "*Gnus Reviews: Series Comments*"
         (format "Comments for patch series: %s"
                 (or (plist-get series-info :subject) "Unknown"))
         series-comments 200)
      (message "No comments found for current patch series"))))

;;;###autoload
(defun gnus-reviews-show-pending-series-comments ()
  "Show only pending comments for the current patch series."
  (interactive)
  (let* ((series-info (gnus-reviews--get-current-patch-series))
         (pending-comments (gnus-reviews-list-pending-comments-for-series)))
    (if pending-comments
        (gnus-reviews--display-comment-list
         "*Gnus Reviews: Pending Series Comments*"
         (format "Pending comments for patch series: %s"
                 (or (plist-get series-info :subject) "Unknown"))
         pending-comments 200)
      (message "No pending comments found for current patch series"))))

;;;###autoload
(defun gnus-reviews-show-article-comments ()
  "Show all individual comments for the current article."
  (interactive)
  (let* ((article-id (gnus-reviews--current-article-id))
         (comments (gnus-reviews-get-comments-for-article article-id)))
    (if comments
        (gnus-reviews--display-comment-list
         "*Gnus Reviews: Article Comments*"
         (format "Individual comments for article: %s" article-id)
         comments 300)
      (message "No individual comments found for current article"))))

;;;###autoload
(defun gnus-reviews-prune-old-reviews ()
  "Remove old completed/dismissed reviews older than specified days.
Uses `gnus-reviews-auto-expire-days' as the cutoff age.
Keeps all pending comments regardless of age."
  (interactive)
  (let ((cutoff-time (time-subtract (current-time)
                                    (days-to-time gnus-reviews-auto-expire-days)))
        (removed-count 0))
    ;; Remove only old completed/dismissed comments, keep pending ones
    (gnus-reviews--store-comments
     (cl-remove-if
      (lambda (entry) (null (cdr entry)))
      (mapcar (lambda (article-entry)
                (cons (car article-entry)
                      (cl-remove-if (lambda (comment)
                                      (let ((comment-time (plist-get (cdr comment) :timestamp))
                                            (status (plist-get (cdr comment) :status)))
                                        (when (and comment-time
                                                   (time-less-p comment-time cutoff-time)
                                                   (memq status '(addressed dismissed)))
                                          (cl-incf removed-count)
                                          t)))
                                    (cdr article-entry))))
              (gnus-reviews--comments))))
    (message "Removed %d old completed comments (kept %d pending ones)"
             removed-count
             (length (gnus-reviews-list-pending-comments)))))

;; Provide the package
(provide 'gnus-reviews)

;;; gnus-reviews.el ends here
